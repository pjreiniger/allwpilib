From 49ffbcca6388421fbc0a2f484c994178d80b28a0 Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Mon, 12 Dec 2022 16:23:09 -0500
Subject: [PATCH 03/12] Use LLVM stream operators, string_view for keys

---
 .../nlohmann/detail/conversions/from_json.hpp |  21 +-
 .../nlohmann/detail/conversions/to_json.hpp   |  48 ++-
 .../nlohmann/detail/input/binary_reader.hpp   |  18 +-
 include/nlohmann/detail/input/lexer.hpp       |  87 +++--
 include/nlohmann/detail/input/parser.hpp      |   4 +-
 .../nlohmann/detail/iterators/iter_impl.hpp   |   4 +-
 .../detail/iterators/iteration_proxy.hpp      |   2 +-
 include/nlohmann/detail/json_pointer.hpp      |  49 ++-
 include/nlohmann/detail/meta/type_traits.hpp  |   2 +-
 .../nlohmann/detail/output/binary_writer.hpp  | 151 ++++----
 include/nlohmann/detail/output/serializer.hpp |  25 +-
 include/nlohmann/json.hpp                     | 321 ++++++++++--------
 12 files changed, 437 insertions(+), 295 deletions(-)

diff --git a/include/nlohmann/detail/conversions/from_json.hpp b/include/nlohmann/detail/conversions/from_json.hpp
index 46aa41d8..d411cdea 100644
--- a/include/nlohmann/detail/conversions/from_json.hpp
+++ b/include/nlohmann/detail/conversions/from_json.hpp
@@ -256,14 +256,23 @@ void from_json(const BasicJsonType& j, CompatibleObjectType& obj)
     }
 
     auto inner_object = j.template get_ptr<const typename BasicJsonType::object_t*>();
+    using std::begin;
+    using std::end;
     using value_type = typename CompatibleObjectType::value_type;
-    std::transform(
-        inner_object->begin(), inner_object->end(),
-        std::inserter(obj, obj.begin()),
-        [](typename BasicJsonType::object_t::value_type const & p)
+    std::vector<value_type> v;
+    v.reserve(j.size());
+    for (const auto& p : *inner_object)
     {
-        return value_type(p.first, p.second.template get<typename CompatibleObjectType::mapped_type>());
-    });
+        v.emplace_back(
+            p.first(),
+            p.second
+            .template get<typename CompatibleObjectType::mapped_type>());
+    }
+    // we could avoid the assignment, but this might require a for loop, which
+    // might be less efficient than the container constructor for some
+    // containers (would it?)
+    obj = CompatibleObjectType(std::make_move_iterator(begin(v)),
+                               std::make_move_iterator(end(v)));
 }
 
 // overload for arithmetic types, not chosen for basic_json template arguments
diff --git a/include/nlohmann/detail/conversions/to_json.hpp b/include/nlohmann/detail/conversions/to_json.hpp
index 0a802369..a382cf60 100644
--- a/include/nlohmann/detail/conversions/to_json.hpp
+++ b/include/nlohmann/detail/conversions/to_json.hpp
@@ -39,15 +39,16 @@ template<>
 struct external_constructor<value_t::string>
 {
     template<typename BasicJsonType>
-    static void construct(BasicJsonType& j, const typename BasicJsonType::string_t& s)
+    static void construct(BasicJsonType& j, std::string_view s)
     {
         j.m_type = value_t::string;
         j.m_value = s;
         j.assert_invariant();
     }
 
-    template<typename BasicJsonType>
-    static void construct(BasicJsonType& j, typename BasicJsonType::string_t&& s)
+    template<typename BasicJsonType, typename T,
+             enable_if_t<std::is_same<std::string, T>::value, int> = 0>
+    static void construct(BasicJsonType& j, T&& s)
     {
         j.m_type = value_t::string;
         j.m_value = std::move(s);
@@ -120,6 +121,16 @@ struct external_constructor<value_t::array>
         j.assert_invariant();
     }
 
+    template<typename BasicJsonType, typename T>
+    static void construct(BasicJsonType& j, std::span<T> arr)
+    {
+        using std::begin;
+        using std::end;
+        j.m_type = value_t::array;
+        j.m_value.array = j.template create<typename BasicJsonType::array_t>(begin(arr), end(arr));
+        j.assert_invariant();
+    }
+
     template<typename BasicJsonType, typename CompatibleArrayType,
              enable_if_t<not std::is_same<CompatibleArrayType, typename BasicJsonType::array_t>::value,
                          int> = 0>
@@ -144,17 +155,6 @@ struct external_constructor<value_t::array>
         }
         j.assert_invariant();
     }
-
-    template<typename BasicJsonType, typename T,
-             enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
-    static void construct(BasicJsonType& j, const std::valarray<T>& arr)
-    {
-        j.m_type = value_t::array;
-        j.m_value = value_t::array;
-        j.m_value.array->resize(arr.size());
-        std::copy(std::begin(arr), std::end(arr), j.m_value.array->begin());
-        j.assert_invariant();
-    }
 };
 
 template<>
@@ -180,11 +180,12 @@ struct external_constructor<value_t::object>
              enable_if_t<not std::is_same<CompatibleObjectType, typename BasicJsonType::object_t>::value, int> = 0>
     static void construct(BasicJsonType& j, const CompatibleObjectType& obj)
     {
-        using std::begin;
-        using std::end;
-
         j.m_type = value_t::object;
-        j.m_value.object = j.template create<typename BasicJsonType::object_t>(begin(obj), end(obj));
+        j.m_value = value_t::object;
+        for (const auto& x : obj)
+        {
+            j.m_value.object->try_emplace(x.first, x.second);
+        }
         j.assert_invariant();
     }
 };
@@ -201,7 +202,7 @@ void to_json(BasicJsonType& j, T b) noexcept
 }
 
 template<typename BasicJsonType, typename CompatibleString,
-         enable_if_t<std::is_constructible<typename BasicJsonType::string_t, CompatibleString>::value, int> = 0>
+         enable_if_t<std::is_constructible<std::string_view, CompatibleString>::value, int> = 0>
 void to_json(BasicJsonType& j, const CompatibleString& s)
 {
     external_constructor<value_t::string>::construct(j, s);
@@ -261,13 +262,6 @@ void to_json(BasicJsonType& j, const CompatibleArrayType& arr)
     external_constructor<value_t::array>::construct(j, arr);
 }
 
-template<typename BasicJsonType, typename T,
-         enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
-void to_json(BasicJsonType& j, const std::valarray<T>& arr)
-{
-    external_constructor<value_t::array>::construct(j, std::move(arr));
-}
-
 template<typename BasicJsonType>
 void to_json(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
 {
@@ -289,7 +283,7 @@ void to_json(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
 
 template <
     typename BasicJsonType, typename T, std::size_t N,
-    enable_if_t<not std::is_constructible<typename BasicJsonType::string_t,
+    enable_if_t<not std::is_constructible<std::string_view,
                 const T (&)[N]>::value,
                 int> = 0 >
 void to_json(BasicJsonType& j, const T (&arr)[N])
diff --git a/include/nlohmann/detail/input/binary_reader.hpp b/include/nlohmann/detail/input/binary_reader.hpp
index e1242a44..ed3ceab4 100644
--- a/include/nlohmann/detail/input/binary_reader.hpp
+++ b/include/nlohmann/detail/input/binary_reader.hpp
@@ -51,10 +51,8 @@ class binary_reader
 
     @param[in] adapter  input adapter to read from
     */
-    explicit binary_reader(input_adapter_t adapter) : ia(std::move(adapter))
+    explicit binary_reader(raw_istream& s) : is(s)
     {
-        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
-        assert(ia);
     }
 
     /*!
@@ -861,7 +859,17 @@ class binary_reader
 //-------EXPORTED_FUNC_CONTENTS_START
     {
         ++chars_read;
-        return (current = ia->get_character());
+        unsigned char c;
+        is.read(c);
+        if (is.has_error())
+        {
+            current = std::char_traits<char>::eof();
+        }
+        else
+        {
+            current = c;
+        }
+        return current;
     }
 //-------EXPORTED_FUNC_CONTENTS_END
 
@@ -1768,7 +1776,7 @@ class binary_reader
 
   private:
     /// input adapter
-    input_adapter_t ia = nullptr;
+    raw_istream& is;
 
     /// the current character
     int current = std::char_traits<char>::eof();
diff --git a/include/nlohmann/detail/input/lexer.hpp b/include/nlohmann/detail/input/lexer.hpp
index 5571bd61..f05b6396 100644
--- a/include/nlohmann/detail/input/lexer.hpp
+++ b/include/nlohmann/detail/input/lexer.hpp
@@ -103,10 +103,36 @@ class lexer
 //-------EXPORTED_FUNC_CONTENTS_END
 
 //-------EXPORTED_FUNC_DEF_START json::lexer
-    explicit lexer(detail::input_adapter_t&& adapter)
+    explicit lexer(raw_istream& adapter)
 //-------EXPORTED_FUNC_DEF_END
 //-------EXPORTED_FUNC_CONTENTS_START
-        : ia(std::move(adapter)), decimal_point_char(get_decimal_point()) {}
+        : is(s), decimal_point_char(get_decimal_point())
+    {
+        // skip byte order mark
+        std::char_traits<char>::int_type c;
+        if ((c = get()) == 0xEF)
+        {
+            if ((c = get()) == 0xBB)
+            {
+                if ((c = get()) == 0xBF)
+                {
+                    chars_read = 0;
+                    return; // Ignore BOM
+                }
+                else if (c != std::char_traits<char>::eof())
+                {
+                    unget();
+                }
+                putback('\xBB');
+            }
+            else if (c != std::char_traits<char>::eof())
+            {
+                unget();
+            }
+            putback('\xEF');
+        }
+        unget(); // no byte order mark; process as usual
+    }
 //-------EXPORTED_FUNC_CONTENTS_END
 
     // delete because of pointer members
@@ -1019,7 +1045,7 @@ scan_number_done:
         // try to parse integers first and fall back to floats
         if (number_type == token_type::value_unsigned)
         {
-            const auto x = std::strtoull(token_buffer.data(), &endptr, 10);
+            const auto x = std::strtoull(token_buffer.c_str(), &endptr, 10);
 
             // we checked the number format before
             assert(endptr == token_buffer.data() + token_buffer.size());
@@ -1035,7 +1061,7 @@ scan_number_done:
         }
         else if (number_type == token_type::value_integer)
         {
-            const auto x = std::strtoll(token_buffer.data(), &endptr, 10);
+            const auto x = std::strtoll(token_buffer.c_str(), &endptr, 10);
 
             // we checked the number format before
             assert(endptr == token_buffer.data() + token_buffer.size());
@@ -1052,7 +1078,7 @@ scan_number_done:
 
         // this code is reached if we parse a floating-point number or if an
         // integer conversion above failed
-        strtof(value_float, token_buffer.data(), &endptr);
+        strtof(value_float, token_buffer.c_str(), &endptr);
 
         // we checked the number format before
         assert(endptr == token_buffer.data() + token_buffer.size());
@@ -1117,19 +1143,23 @@ scan_number_done:
 //-------EXPORTED_FUNC_CONTENTS_START
     {
         ++chars_read;
-        if (next_unget)
+        if (JSON_UNLIKELY(!unget_chars.empty()))
         {
-            // just reset the next_unget variable and work with current
-            next_unget = false;
+            current = unget_chars.back();
+            unget_chars.pop_back();
+            token_string.push_back(current);
+            return current;
         }
-        else
+        char c;
+        is.read(c);
+        if (JSON_UNLIKELY(is.has_error()))
         {
-            current = ia->get_character();
+            current = std::char_traits<char>::eof();
         }
-
-        if (JSON_LIKELY(current != std::char_traits<char>::eof()))
+        else
         {
-            token_string.push_back(std::char_traits<char>::to_char_type(current));
+            current = std::char_traits<char>::to_int_type(c);
+            token_string.push_back(c);
         }
         return current;
     }
@@ -1152,8 +1182,13 @@ scan_number_done:
         --chars_read;
         if (JSON_LIKELY(current != std::char_traits<char>::eof()))
         {
+            unget_chars.emplace_back(current);
             assert(token_string.size() != 0);
             token_string.pop_back();
+            if (!token_string.empty())
+            {
+                current = token_string.back();
+            }
         }
     }
 //-------EXPORTED_FUNC_CONTENTS_END
@@ -1187,8 +1222,8 @@ scan_number_done:
         return value_float;
     }
 
-    /// return current string value (implicitly resets the token; useful only once)
-    string_t& get_string()
+    /// return current string value
+    std::string_view get_string()
     {
         return token_buffer;
     }
@@ -1213,22 +1248,22 @@ scan_number_done:
     {
         // escape control characters
         std::string result;
-        for (const auto c : token_string)
+        raw_string_ostream ss(result);
+        for (const unsigned char c : token_string)
         {
-            if ('\x00' <= c and c <= '\x1F')
+            if (c <= '\x1F')
             {
                 // escape control characters
-                char cs[9];
-                snprintf(cs, 9, "<U+%.4X>", static_cast<unsigned char>(c));
-                result += cs;
+                ss << fmt::format("<U+{:04X}>", c);
             }
             else
             {
                 // add character as is
-                result.push_back(c);
+                ss << c;
             }
         }
 
+        ss.flush();
         return result;
     }
 //-------EXPORTED_FUNC_CONTENTS_END
@@ -1352,22 +1387,22 @@ scan_number_done:
 
   private:
     /// input adapter
-    detail::input_adapter_t ia = nullptr;
+    raw_istream& is;
 
     /// the current character
     std::char_traits<char>::int_type current = std::char_traits<char>::eof();
 
-    /// whether the next get() call should just return current
-    bool next_unget = false;
+    /// unget characters
+    SmallVector<std::char_traits<char>::int_type, 4> unget_chars;
 
     /// the number of characters read
     std::size_t chars_read = 0;
 
     /// raw input token string (for error messages)
-    std::vector<char> token_string {};
+    SmallString<128> token_string {};
 
     /// buffer for variable-length tokens (numbers, strings)
-    string_t token_buffer {};
+    SmallString<128> token_buffer {};
 
     /// a description of occurred lexer errors
     const char* error_message = "";
diff --git a/include/nlohmann/detail/input/parser.hpp b/include/nlohmann/detail/input/parser.hpp
index dca89f5c..e59eafa8 100644
--- a/include/nlohmann/detail/input/parser.hpp
+++ b/include/nlohmann/detail/input/parser.hpp
@@ -63,10 +63,10 @@ class parser
         std::function<bool(int depth, parse_event_t event, BasicJsonType& parsed)>;
 
     /// a parser reading from an input adapter
-    explicit parser(detail::input_adapter_t&& adapter,
+    explicit parser(raw_istream& s,
                     const parser_callback_t cb = nullptr,
                     const bool allow_exceptions_ = true)
-        : callback(cb), m_lexer(std::move(adapter)), allow_exceptions(allow_exceptions_)
+        : callback(cb), m_lexer(s), allow_exceptions(allow_exceptions_)
     {
         // read first token
         get_token();
diff --git a/include/nlohmann/detail/iterators/iter_impl.hpp b/include/nlohmann/detail/iterators/iter_impl.hpp
index 45fa6972..33975d13 100644
--- a/include/nlohmann/detail/iterators/iter_impl.hpp
+++ b/include/nlohmann/detail/iterators/iter_impl.hpp
@@ -589,13 +589,13 @@ class iter_impl
     @brief  return the key of an object iterator
     @pre The iterator is initialized; i.e. `m_object != nullptr`.
     */
-    const typename object_t::key_type& key() const
+    std::string_view key() const
     {
         assert(m_object != nullptr);
 
         if (JSON_LIKELY(m_object->is_object()))
         {
-            return m_it.object_iterator->first;
+            return m_it.object_iterator->first();
         }
 
         JSON_THROW(invalid_iterator::create(207, "cannot use key() for non-object iterators"));
diff --git a/include/nlohmann/detail/iterators/iteration_proxy.hpp b/include/nlohmann/detail/iterators/iteration_proxy.hpp
index f5dbb2c7..a26440f2 100644
--- a/include/nlohmann/detail/iterators/iteration_proxy.hpp
+++ b/include/nlohmann/detail/iterators/iteration_proxy.hpp
@@ -89,7 +89,7 @@ template<typename IteratorType> class iteration_proxy
 
                 // use key from the object
                 case value_t::object:
-                    return anchor.key();
+                    return std::string{anchor.key()};
 
                 // use an empty key for all primitive types
                 default:
diff --git a/include/nlohmann/detail/json_pointer.hpp b/include/nlohmann/detail/json_pointer.hpp
index 995d223c..870d0509 100644
--- a/include/nlohmann/detail/json_pointer.hpp
+++ b/include/nlohmann/detail/json_pointer.hpp
@@ -39,7 +39,7 @@ class json_pointer
 
     @since version 2.0.0
     */
-    explicit json_pointer(const std::string& s = "")
+    explicit json_pointer(std::string_view s = {})
         : reference_tokens(split(s))
     {}
 
@@ -86,17 +86,18 @@ class json_pointer
     @throw out_of_range.404 if string @a s could not be converted to an integer
     */
 //-------EXPORTED_FUNC_DEF_START json_pointer
-    static int array_index(const std::string& s)
+    static int array_index(std::string_view s)
 //-------EXPORTED_FUNC_DEF_END
 //-------EXPORTED_FUNC_CONTENTS_START
     {
+        SmallString<128> str{s};
         std::size_t processed_chars = 0;
-        const int res = std::stoi(s, &processed_chars);
+        const int res = std::stoi(str.c_str(), &processed_chars);
 
         // check if the string was completely read
-        if (JSON_UNLIKELY(processed_chars != s.size()))
+        if (JSON_UNLIKELY(processed_chars != str.size()))
         {
-            JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + s + "'"));
+            JSON_THROW(detail::out_of_range::create(404, fmt::format("unresolved reference token '{}'", s)));
         }
 
         return res;
@@ -516,7 +517,7 @@ class json_pointer
     @throw parse_error.108  if character '~' is not followed by '0' or '1'
     */
 //-------EXPORTED_FUNC_DEF_START json_pointer
-    static std::vector<std::string> split(const std::string& reference_string)
+    static std::vector<std::string> split(std::string_view reference_string)
 //-------EXPORTED_FUNC_DEF_END
 //-------EXPORTED_FUNC_CONTENTS_START
     {
@@ -640,7 +641,7 @@ class json_pointer
     @note Empty objects or arrays are flattened to `null`.
     */
 //-------EXPORTED_FUNC_DEF_START json_pointer
-    static void flatten(const std::string& reference_string,
+    static void flatten(std::string_view reference_string,
                         const BasicJsonType& value,
                         BasicJsonType& result)
 //-------EXPORTED_FUNC_DEF_END
@@ -716,21 +717,35 @@ class json_pointer
             JSON_THROW(detail::type_error::create(314, "only objects can be unflattened"));
         }
 
-        BasicJsonType result;
-
-        // iterate the JSON object values
-        for (const auto& element : *value.m_value.object)
+        // we need to iterate over the object values in sorted key order
+        SmallVector<StringMapConstIterator<json>, 64> sorted;
+        for (auto i = value.m_value.object->begin(),
+             end = value.m_value.object->end(); i != end; ++i)
         {
-            if (JSON_UNLIKELY(not element.second.is_primitive()))
+            if (!i->second.is_primitive())
             {
                 JSON_THROW(detail::type_error::create(315, "values in object must be primitive"));
             }
+            sorted.push_back(i);
+        }
+        std::sort(sorted.begin(), sorted.end(),
+                  [](const StringMapConstIterator<json>& a,
+                     const StringMapConstIterator<json>& b) {
+                    return a->getKey() < b->getKey();
+                  });
+
+        json result;
+
+        // iterate the sorted JSON object values
+        for (const auto& element : sorted)
+        {
 
-            // assign value to reference pointed to by JSON pointer; Note that if
-            // the JSON pointer is "" (i.e., points to the whole value), function
-            // get_and_create returns a reference to result itself. An assignment
-            // will then create a primitive value.
-            json_pointer(element.first).get_and_create(result) = element.second;
+            // assign value to reference pointed to by JSON pointer; Note
+            // that if the JSON pointer is "" (i.e., points to the whole
+            // value), function get_and_create returns a reference to
+            // result itself. An assignment will then create a primitive
+            // value.
+            json_pointer(element->first()).get_and_create(result) = element->second;
         }
 
         return result;
diff --git a/include/nlohmann/detail/meta/type_traits.hpp b/include/nlohmann/detail/meta/type_traits.hpp
index b4b630c2..0b68e831 100644
--- a/include/nlohmann/detail/meta/type_traits.hpp
+++ b/include/nlohmann/detail/meta/type_traits.hpp
@@ -112,7 +112,7 @@ struct is_compatible_object_type_impl <
 
     // macOS's is_constructible does not play well with nonesuch...
     static constexpr bool value =
-        std::is_constructible<typename object_t::key_type,
+        std::is_constructible<std::string_view,
         typename CompatibleObjectType::key_type>::value and
         std::is_constructible<typename object_t::mapped_type,
         typename CompatibleObjectType::mapped_type>::value;
diff --git a/include/nlohmann/detail/output/binary_writer.hpp b/include/nlohmann/detail/output/binary_writer.hpp
index 3fbb0a2e..7758effa 100644
--- a/include/nlohmann/detail/output/binary_writer.hpp
+++ b/include/nlohmann/detail/output/binary_writer.hpp
@@ -35,9 +35,8 @@ class binary_writer
 
     @param[in] adapter  output adapter to write to
     */
-    explicit binary_writer(output_adapter_t<CharType> adapter) : oa(adapter)
+    explicit binary_writer(raw_ostream& s) : o(s)
     {
-        assert(oa);
     }
 
     /*!
@@ -167,39 +166,7 @@ class binary_writer
 
             case value_t::string:
             {
-                // step 1: write control byte and the string length
-                const auto N = j.m_value.string->size();
-                if (N <= 0x17)
-                {
-                    write_number(static_cast<uint8_t>(0x60 + N));
-                }
-                else if (N <= (std::numeric_limits<uint8_t>::max)())
-                {
-                    oa->write_character(static_cast<CharType>(0x78));
-                    write_number(static_cast<uint8_t>(N));
-                }
-                else if (N <= (std::numeric_limits<uint16_t>::max)())
-                {
-                    oa->write_character(static_cast<CharType>(0x79));
-                    write_number(static_cast<uint16_t>(N));
-                }
-                else if (N <= (std::numeric_limits<uint32_t>::max)())
-                {
-                    oa->write_character(static_cast<CharType>(0x7A));
-                    write_number(static_cast<uint32_t>(N));
-                }
-                // LCOV_EXCL_START
-                else if (N <= (std::numeric_limits<uint64_t>::max)())
-                {
-                    oa->write_character(static_cast<CharType>(0x7B));
-                    write_number(static_cast<uint64_t>(N));
-                }
-                // LCOV_EXCL_STOP
-
-                // step 2: write the string
-                oa->write_characters(
-                    reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
-                    j.m_value.string->size());
+                write_cbor_string(*j.m_value.string);
                 break;
             }
 
@@ -276,7 +243,7 @@ class binary_writer
                 // step 2: write each element
                 for (const auto& el : *j.m_value.object)
                 {
-                    write_cbor(el.first);
+                    write_cbor_string(el.first());
                     write_cbor(el.second);
                 }
                 break;
@@ -431,36 +398,7 @@ class binary_writer
 
             case value_t::string:
             {
-                // step 1: write control byte and the string length
-                const auto N = j.m_value.string->size();
-                if (N <= 31)
-                {
-                    // fixstr
-                    write_number(static_cast<uint8_t>(0xA0 | N));
-                }
-                else if (N <= (std::numeric_limits<uint8_t>::max)())
-                {
-                    // str 8
-                    oa->write_character(static_cast<CharType>(0xD9));
-                    write_number(static_cast<uint8_t>(N));
-                }
-                else if (N <= (std::numeric_limits<uint16_t>::max)())
-                {
-                    // str 16
-                    oa->write_character(static_cast<CharType>(0xDA));
-                    write_number(static_cast<uint16_t>(N));
-                }
-                else if (N <= (std::numeric_limits<uint32_t>::max)())
-                {
-                    // str 32
-                    oa->write_character(static_cast<CharType>(0xDB));
-                    write_number(static_cast<uint32_t>(N));
-                }
-
-                // step 2: write the string
-                oa->write_characters(
-                    reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
-                    j.m_value.string->size());
+                write_msgpack_string(*j.m_value.string);
                 break;
             }
 
@@ -519,7 +457,7 @@ class binary_writer
                 // step 2: write each element
                 for (const auto& el : *j.m_value.object)
                 {
-                    write_msgpack(el.first);
+                    write_msgpack_string(el.first());
                     write_msgpack(el.second);
                 }
                 break;
@@ -695,6 +633,81 @@ class binary_writer
 //-------EXPORTED_FUNC_CONTENTS_END
 
   private:
+//-------EXPORTED_FUNC_DEF_START binary_writer
+    void write_cbor_string(std::string_view str)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
+    {
+        // step 1: write control byte and the string length
+        const auto N = str.size();
+        if (N <= 0x17)
+        {
+            write_number(static_cast<uint8_t>(0x60 + N));
+        }
+        else if (N <= (std::numeric_limits<uint8_t>::max)())
+        {
+            o << static_cast<CharType>(0x78);
+            write_number(static_cast<uint8_t>(N));
+        }
+        else if (N <= (std::numeric_limits<uint16_t>::max)())
+        {
+            o << static_cast<CharType>(0x79);
+            write_number(static_cast<uint16_t>(N));
+        }
+        else if (N <= (std::numeric_limits<uint32_t>::max)())
+        {
+            o << static_cast<CharType>(0x7A);
+            write_number(static_cast<uint32_t>(N));
+        }
+        // LCOV_EXCL_START
+        else if (N <= (std::numeric_limits<uint64_t>::max)())
+        {
+            o << static_cast<CharType>(0x7B);
+            write_number(static_cast<uint64_t>(N));
+        }
+        // LCOV_EXCL_STOP
+
+        // step 2: write the string
+        o << str;
+    }
+//-------EXPORTED_FUNC_CONTENTS_END
+
+//-------EXPORTED_FUNC_DEF_START binary_writer
+    void write_msgpack_string(std::string_view str)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
+    {
+        // step 1: write control byte and the string length
+        const auto N = str.size();
+        if (N <= 31)
+        {
+            // fixstr
+            write_number(static_cast<uint8_t>(0xA0 | N));
+        }
+        else if (N <= (std::numeric_limits<uint8_t>::max)())
+        {
+            // str 8
+            o << static_cast<CharType>(0xD9);
+            write_number(static_cast<uint8_t>(N));
+        }
+        else if (N <= (std::numeric_limits<uint16_t>::max)())
+        {
+            // str 16
+            o << static_cast<CharType>(0xDA);
+            write_number(static_cast<uint16_t>(N));
+        }
+        else if (N <= (std::numeric_limits<uint32_t>::max)())
+        {
+            // str 32
+            o << static_cast<CharType>(0xDB);
+            write_number(static_cast<uint32_t>(N));
+        }
+
+        // step 2: write the string
+        o << str;
+    }
+//-------EXPORTED_FUNC_CONTENTS_END
+
     /*
     @brief write a number to output input
 
@@ -722,7 +735,7 @@ class binary_writer
             std::reverse(vec.begin(), vec.end());
         }
 
-        oa->write_characters(vec.data(), sizeof(NumberType));
+        o << std::span{vec.data(), sizeof(NumberType)};
     }
 //-------EXPORTED_FUNC_CONTENTS_END
 
@@ -981,7 +994,7 @@ class binary_writer
     const bool is_little_endian = json::binary_reader::little_endianess();
 
     /// the output
-    output_adapter_t<CharType> oa = nullptr;
+    raw_ostream& o;
 };
 }
 }
diff --git a/include/nlohmann/detail/output/serializer.hpp b/include/nlohmann/detail/output/serializer.hpp
index 50436031..c4fa0169 100644
--- a/include/nlohmann/detail/output/serializer.hpp
+++ b/include/nlohmann/detail/output/serializer.hpp
@@ -42,8 +42,8 @@ class serializer
     @param[in] s  output stream to serialize to
     @param[in] ichar  indentation character to use
     */
-    serializer(output_adapter_t<char> s, const char ichar)
-        : o(std::move(s)), loc(std::localeconv()),
+    serializer(raw_ostream& s, const char ichar)
+        : o(s), loc(std::localeconv()),
           thousands_sep(loc->thousands_sep == nullptr ? '\0' : * (loc->thousands_sep)),
           decimal_point(loc->decimal_point == nullptr ? '\0' : * (loc->decimal_point)),
           indent_char(ichar), indent_string(512, indent_char)
@@ -88,6 +88,19 @@ class serializer
                     return;
                 }
 
+                // we need to iterate over the object values in sorted key order
+                SmallVector<StringMapConstIterator<json>, 64> sorted;
+                for (auto i = val.m_value.object->begin(),
+                     end = val.m_value.object->end(); i != end; ++i)
+                {
+                    sorted.push_back(i);
+                }
+                std::sort(sorted.begin(), sorted.end(),
+                          [](const StringMapConstIterator<json>& a,
+                             const StringMapConstIterator<json>& b) {
+                            return a->getKey() < b->getKey();
+                          });
+
                 if (pretty_print)
                 {
                     o->write_characters("{\n", 2);
@@ -100,7 +113,7 @@ class serializer
                     }
 
                     // first n-1 elements
-                    auto i = val.m_value.object->cbegin();
+                    auto i = sorted.begin();
                     for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
                     {
                         o->write_characters(indent_string.c_str(), new_indent);
@@ -112,7 +125,7 @@ class serializer
                     }
 
                     // last element
-                    assert(i != val.m_value.object->cend());
+                    assert(i != sorted.end());
                     assert(std::next(i) == val.m_value.object->cend());
                     o->write_characters(indent_string.c_str(), new_indent);
                     o->write_character('\"');
@@ -282,7 +295,7 @@ class serializer
     @complexity Linear in the length of string @a s.
     */
 //-------EXPORTED_FUNC_DEF_START json::serializer
-    void dump_escaped(const string_t& s, const bool ensure_ascii)
+    void dump_escaped(std::string_view s, const bool ensure_ascii)
 //-------EXPORTED_FUNC_DEF_END
 //-------EXPORTED_FUNC_CONTENTS_START
     {
@@ -622,7 +635,7 @@ class serializer
 
   private:
     /// the output of the serializer
-    output_adapter_t<char> o = nullptr;
+    raw_ostream& o;
 
     /// a (hopefully) large enough character buffer
     std::array<char, 64> number_buffer{{}};
diff --git a/include/nlohmann/json.hpp b/include/nlohmann/json.hpp
index 70ea6e43..9bed5577 100644
--- a/include/nlohmann/json.hpp
+++ b/include/nlohmann/json.hpp
@@ -460,11 +460,7 @@ class basic_json
     7159](http://rfc7159.net/rfc7159), because any order implements the
     specified "unordered" nature of JSON objects.
     */
-    using object_t = ObjectType<StringType,
-          basic_json,
-          object_comparator_t,
-          AllocatorType<std::pair<const StringType,
-          basic_json>>>;
+    using object_t = StringMap<json>;
 
     /*!
     @brief a type for an array
@@ -947,6 +943,12 @@ class basic_json
         }
 //-------EXPORTED_FUNC_CONTENTS_END
 
+        /// constructor for strings
+        json_value(std::string_view value)
+        {
+            string = create<std::string>(value);
+        }
+
         /// constructor for strings
         json_value(const string_t& value)
         {
@@ -1694,13 +1696,6 @@ class basic_json
                 break;
             }
 
-            case value_t::object:
-            {
-                m_value.object = create<object_t>(first.m_it.object_iterator,
-                                                  last.m_it.object_iterator);
-                break;
-            }
-
             case value_t::array:
             {
                 m_value.array = create<array_t>(first.m_it.array_iterator,
@@ -1975,8 +1970,20 @@ class basic_json
 //-------EXPORTED_FUNC_DEF_END
 //-------EXPORTED_FUNC_CONTENTS_START
     {
-        string_t result;
-        serializer s(detail::output_adapter<char, string_t>(result), indent_char);
+        std::string result;
+        raw_string_ostream os(result);
+        dump(os, indent, indent_char, ensure_ascii);
+        return result;
+    }
+//-------EXPORTED_FUNC_CONTENTS_END
+
+//-------EXPORTED_FUNC_DEF_START json
+    void dump(raw_ostream& os, int indent = -1, const char indent_char = ' ',
+              const bool ensure_ascii = false) const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
+    {
+        serializer s(os, indent_char);
 
         if (indent >= 0)
         {
@@ -1987,7 +1994,7 @@ class basic_json
             s.dump(*this, false, ensure_ascii, 0);
         }
 
-        return result;
+        os.flush();
     }
 //-------EXPORTED_FUNC_CONTENTS_END
 
@@ -3012,15 +3019,13 @@ class basic_json
         // at only works for objects
         if (JSON_LIKELY(is_object()))
         {
-            JSON_TRY
-            {
-                return m_value.object->at(key);
-            }
-            JSON_CATCH (std::out_of_range&)
+            auto it = m_value.object->find(key);
+            if (it == m_value.object->end())
             {
                 // create better exception explanation
                 JSON_THROW(out_of_range::create(403, "key '" + key + "' not found"));
             }
+            return it->second;
         }
         else
         {
@@ -3067,15 +3072,13 @@ class basic_json
         // at only works for objects
         if (JSON_LIKELY(is_object()))
         {
-            JSON_TRY
-            {
-                return m_value.object->at(key);
-            }
-            JSON_CATCH (std::out_of_range&)
+            auto it = m_value.object->find(key);
+            if (it == m_value.object->end())
             {
                 // create better exception explanation
                 JSON_THROW(out_of_range::create(403, "key '" + key + "' not found"));
             }
+            return it->second;
         }
         else
         {
@@ -3644,7 +3647,7 @@ class basic_json
                  std::is_same<IteratorType, typename basic_json_t::iterator>::value or
                  std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int>::type
              = 0>
-    IteratorType erase(IteratorType pos)
+    void erase(IteratorType pos)
     {
         // make sure iterator fits the current value
         if (JSON_UNLIKELY(this != pos.m_object))
@@ -3652,8 +3655,6 @@ class basic_json
             JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
         }
 
-        IteratorType result = end();
-
         switch (m_type)
         {
             case value_t::boolean:
@@ -3682,21 +3683,19 @@ class basic_json
 
             case value_t::object:
             {
-                result.m_it.object_iterator = m_value.object->erase(pos.m_it.object_iterator);
+                m_value.object->erase(pos.m_it.object_iterator);
                 break;
             }
 
             case value_t::array:
             {
-                result.m_it.array_iterator = m_value.array->erase(pos.m_it.array_iterator);
+                m_value.array->erase(pos.m_it.array_iterator);
                 break;
             }
 
             default:
                 JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
         }
-
-        return result;
     }
 
     /*!
@@ -3786,13 +3785,6 @@ class basic_json
                 break;
             }
 
-            case value_t::object:
-            {
-                result.m_it.object_iterator = m_value.object->erase(first.m_it.object_iterator,
-                                              last.m_it.object_iterator);
-                break;
-            }
-
             case value_t::array:
             {
                 result.m_it.array_iterator = m_value.array->erase(first.m_it.array_iterator,
@@ -3938,7 +3930,7 @@ class basic_json
 
         if (is_object())
         {
-            result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));
+            result.m_it.object_iterator = m_value.object->find(key);
         }
 
         return result;
@@ -3958,7 +3950,7 @@ class basic_json
 
         if (is_object())
         {
-            result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));
+            result.m_it.object_iterator = m_value.object->find(key);
         }
 
         return result;
@@ -3992,7 +3984,7 @@ class basic_json
 //-------EXPORTED_FUNC_CONTENTS_START
     {
         // return 0 for all nonobject types
-        return is_object() ? m_value.object->count(std::forward<KeyT>(key)) : 0;
+        return is_object() ? m_value.object->count(key) : 0;
     }
 //-------EXPORTED_FUNC_CONTENTS_END
 
@@ -4633,8 +4625,8 @@ class basic_json
 
             case value_t::object:
             {
-                // delegate call to object_t::max_size()
-                return m_value.object->max_size();
+                // delegate call to std::allocator<object_t>::max_size()
+                return std::allocator_traits<object_t>::max_size(*m_value.object);
             }
 
             default:
@@ -4861,12 +4853,13 @@ class basic_json
 
     @since version 1.0.0
     */
-    void push_back(const typename object_t::value_type& val)
+    template<typename T, typename U>
+    void push_back(const std::pair<T, U>& val)
     {
         // push_back only works for null objects or objects
         if (JSON_UNLIKELY(not(is_null() or is_object())))
         {
-            JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
+            JSON_THROW(type_error::create(308, "cannot use push_back() with", type_name()));
         }
 
         // transform null object into an object
@@ -4878,14 +4871,15 @@ class basic_json
         }
 
         // add element to array
-        m_value.object->insert(val);
+        m_value.object->try_emplace(val.first, std::move(val.second));
     }
 
     /*!
     @brief add an object to an object
     @copydoc push_back(const typename object_t::value_type&)
     */
-    reference operator+=(const typename object_t::value_type& val)
+    template<typename T, typename U>
+    reference operator+=(const std::pair<T, U>& val)
     {
         push_back(val);
         return *this;
@@ -4923,9 +4917,8 @@ class basic_json
     {
         if (is_object() and init.size() == 2 and (*init.begin())->is_string())
         {
-            basic_json&& key = init.begin()->moved_or_copied();
-            push_back(typename object_t::value_type(
-                          std::move(key.get_ref<string_t&>()), (init.begin() + 1)->moved_or_copied()));
+            std::string key = init.begin()->moved_or_copied();
+            push_back(std::pair<std::string_view, json>(key, (init.begin() + 1)->moved_or_copied()));
         }
         else
         {
@@ -5014,7 +5007,7 @@ class basic_json
     @since version 2.0.8
     */
     template<class... Args>
-    std::pair<iterator, bool> emplace(Args&& ... args)
+    std::pair<iterator, bool> emplace(std::string_view key, Args&& ... args)
     {
         // emplace only works for null objects or arrays
         if (JSON_UNLIKELY(not(is_null() or is_object())))
@@ -5031,7 +5024,7 @@ class basic_json
         }
 
         // add element to array (perfect forwarding)
-        auto res = m_value.object->emplace(std::forward<Args>(args)...);
+        auto res = m_value.object->try_emplace(key, std::forward<Args>(args)...);
         // create result iterator and set iterator to the result of emplace
         auto it = begin();
         it.m_it.object_iterator = res.first;
@@ -5314,7 +5307,10 @@ class basic_json
             JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects"));
         }
 
-        m_value.object->insert(first.m_it.object_iterator, last.m_it.object_iterator);
+        for (auto it = first.m_it.object_iterator, end = last.m_it.object_iterator; it != end; ++it)
+        {
+            m_value.object->insert(std::make_pair(it->first(), it->second));
+        }
     }
 //-------EXPORTED_FUNC_CONTENTS_END
 
@@ -6057,20 +6053,11 @@ class basic_json
     @since version 1.0.0; indentation character added in version 3.0.0
     */
 //-------EXPORTED_FUNC_DEF_START json
-    friend std::ostream& operator<<(std::ostream& o, const basic_json& j)
+    friend raw_ostream& operator<<(raw_ostream& o, const json& j)
 //-------EXPORTED_FUNC_DEF_END
 //-------EXPORTED_FUNC_CONTENTS_START
     {
-        // read width member and use it as indentation parameter if nonzero
-        const bool pretty_print = (o.width() > 0);
-        const auto indentation = (pretty_print ? o.width() : 0);
-
-        // reset width to 0 for subsequent calls to this stream
-        o.width(0);
-
-        // do the actual serialization
-        serializer s(detail::output_adapter<char>(o), o.fill());
-        s.dump(j, pretty_print, false, static_cast<unsigned int>(indentation));
+        j.dump(o, 0);
         return o;
     }
 //-------EXPORTED_FUNC_CONTENTS_END
@@ -6162,24 +6149,62 @@ class basic_json
     @since version 2.0.3 (contiguous containers)
     */
 //-------EXPORTED_FUNC_DEF_START json
-    static basic_json parse(detail::input_adapter&& i,
+    static basic_json parse(std::string_view s,
                             const parser_callback_t cb = nullptr,
                             const bool allow_exceptions = true)
 //-------EXPORTED_FUNC_DEF_END
 //-------EXPORTED_FUNC_CONTENTS_START
     {
-        basic_json result;
+        raw_mem_istream is(std::span<const char>(s.data(), s.size()));
+        return parse(is, cb, allow_exceptions);
+    }
+//-------EXPORTED_FUNC_CONTENTS_END
+
+//-------EXPORTED_FUNC_DEF_START json
+    static basic_json parse(std::span<const uint8_t> arr,
+                            const parser_callback_t cb = nullptr,
+                            const bool allow_exceptions = true)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
+    {
+        raw_mem_istream is(arr);
+        return parse(is, cb, allow_exceptions);
+    }
+//-------EXPORTED_FUNC_CONTENTS_END
+
+    /*!
+    @copydoc basic_json parse(raw_istream&, const parser_callback_t)
+    */
+//-------EXPORTED_FUNC_DEF_START json
+    static json parse(raw_istream& i,
+                            const parser_callback_t cb = nullptr,
+                            const bool allow_exceptions = true)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
+    {
+        json result;
         parser(i, cb, allow_exceptions).parse(true, result);
         return result;
     }
 //-------EXPORTED_FUNC_CONTENTS_END
 
 //-------EXPORTED_FUNC_DEF_START json
-    static bool accept(detail::input_adapter&& i)
+    static bool accept(std::string_view s)
 //-------EXPORTED_FUNC_DEF_END
 //-------EXPORTED_FUNC_CONTENTS_START
     {
-        return parser(i).accept(true);
+        raw_mem_istream is(std::span<const char>(s.data(), s.size()));
+        return parser(is).accept(true);
+    }
+//-------EXPORTED_FUNC_CONTENTS_END
+
+//-------EXPORTED_FUNC_DEF_START json
+    static bool accept(std::span<const uint8_t> arr)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
+    {
+        raw_mem_istream is(arr);
+        return parser(is).accept(true);
     }
 //-------EXPORTED_FUNC_CONTENTS_END
 
@@ -6298,10 +6323,11 @@ class basic_json
     @since version 1.0.0
     */
 //-------EXPORTED_FUNC_DEF_START
-    friend std::istream& operator>>(std::istream& i, basic_json& j)
+    friend raw_istream& operator>>(raw_istream& i, basic_json& j)
 //-------EXPORTED_FUNC_DEF_END
 //-------EXPORTED_FUNC_CONTENTS_START
     {
+        json::parser(i).parse(false, j);
         return i;
     }
 //-------EXPORTED_FUNC_CONTENTS_END
@@ -6469,7 +6495,7 @@ class basic_json
     vector in CBOR format.,to_cbor}
 
     @sa http://cbor.io
-    @sa @ref from_cbor(detail::input_adapter, const bool strict) for the
+    @sa @ref from_cbor(raw_istream&, const bool strict) for the
         analogous deserialization
     @sa @ref to_msgpack(const basic_json&) for the related MessagePack format
     @sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
@@ -6483,24 +6509,40 @@ class basic_json
 //-------EXPORTED_FUNC_CONTENTS_START
     {
         std::vector<uint8_t> result;
-        to_cbor(j, result);
+        raw_uvector_ostream os(result);
+        to_cbor(os, j);
         return result;
     }
 //-------EXPORTED_FUNC_CONTENTS_END
 //-------EXPORTED_FUNC_DEF_START json
-    static void to_cbor(const basic_json& j, detail::output_adapter<uint8_t> o)
+    static std::span<uint8_t> to_cbor(const basic_json& j, std::vector<uint8_t>& buf)
 //-------EXPORTED_FUNC_DEF_END
 //-------EXPORTED_FUNC_CONTENTS_START
     {
-        binary_writer<uint8_t>(o).write_cbor(j);
+        buf.clear();
+        raw_uvector_ostream os(buf);
+        to_cbor(os, j);
+        return os.array();
     }
 //-------EXPORTED_FUNC_CONTENTS_END
 //-------EXPORTED_FUNC_DEF_START json
-    static void to_cbor(const basic_json& j, detail::output_adapter<char> o)
+    static std::span<uint8_t> to_cbor(const basic_json& j, SmallVectorImpl<uint8_t>& buf)
 //-------EXPORTED_FUNC_DEF_END
 //-------EXPORTED_FUNC_CONTENTS_START
     {
-        binary_writer<char>(o).write_cbor(j);
+        buf.clear();
+        raw_usvector_ostream os(buf);
+        to_cbor(os, j);
+        return os.array();
+    }
+//-------EXPORTED_FUNC_CONTENTS_END
+
+//-------EXPORTED_FUNC_DEF_START json
+    static void to_cbor(raw_ostream& os, const basic_json& j)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
+    {
+        binary_writer(os).write_cbor(j);
     }
 //-------EXPORTED_FUNC_CONTENTS_END
 
@@ -6590,24 +6632,40 @@ class basic_json
 //-------EXPORTED_FUNC_CONTENTS_START
     {
         std::vector<uint8_t> result;
-        to_msgpack(j, result);
+        raw_uvector_ostream os(result);
+        to_msgpack(os, j);
         return result;
     }
 //-------EXPORTED_FUNC_CONTENTS_END
 //-------EXPORTED_FUNC_DEF_START json
-    static void to_msgpack(const basic_json& j, detail::output_adapter<uint8_t> o)
+    static std::span<uint8_t> to_msgpack(const basic_json& j, std::vector<uint8_t>& buf)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
+    {
+        buf.clear();
+        raw_uvector_ostream os(buf);
+        to_msgpack(os, j);
+        return os.array();
+    }
+//-------EXPORTED_FUNC_CONTENTS_END
+
+//-------EXPORTED_FUNC_DEF_START  json
+    static std::span<uint8_t> to_msgpack(const basic_json& j, SmallVectorImpl<uint8_t>& buf)
 //-------EXPORTED_FUNC_DEF_END
 //-------EXPORTED_FUNC_CONTENTS_START
     {
-        binary_writer<uint8_t>(o).write_msgpack(j);
+        buf.clear();
+        raw_usvector_ostream os(buf);
+        to_msgpack(os, j);
+        return os.array();
     }
 //-------EXPORTED_FUNC_CONTENTS_END
 //-------EXPORTED_FUNC_DEF_START json
-    static void to_msgpack(const basic_json& j, detail::output_adapter<char> o)
+    static void to_msgpack(raw_ostream& os, const json& j)
 //-------EXPORTED_FUNC_DEF_END
 //-------EXPORTED_FUNC_CONTENTS_START
     {
-        binary_writer<char>(o).write_msgpack(j);
+        binary_writer(os).write_msgpack(j);
     }
 //-------EXPORTED_FUNC_CONTENTS_END
 
@@ -6684,7 +6742,7 @@ class basic_json
     vector in UBJSON format.,to_ubjson}
 
     @sa http://ubjson.org
-    @sa @ref from_ubjson(detail::input_adapter, const bool strict) for the
+    @sa @ref from_ubjson(raw_istream&, const bool strict) for the
         analogous deserialization
     @sa @ref to_cbor(const basic_json& for the related CBOR format
     @sa @ref to_msgpack(const basic_json&) for the related MessagePack format
@@ -6699,26 +6757,43 @@ class basic_json
 //-------EXPORTED_FUNC_CONTENTS_START
     {
         std::vector<uint8_t> result;
-        to_ubjson(j, result, use_size, use_type);
+        raw_uvector_ostream os(result);
+        to_ubjson(os, j, use_size, use_type);
         return result;
     }
 //-------EXPORTED_FUNC_CONTENTS_END
 //-------EXPORTED_FUNC_DEF_START json
-    static void to_ubjson(const basic_json& j, detail::output_adapter<uint8_t> o,
+    static std::span<uint8_t> to_ubjson(const basic_json& j, std::vector<uint8_t>& buf,
                           const bool use_size = false, const bool use_type = false)
 //-------EXPORTED_FUNC_DEF_END
 //-------EXPORTED_FUNC_CONTENTS_START
     {
-        binary_writer<uint8_t>(o).write_ubjson(j, use_size, use_type);
+        buf.clear();
+        raw_uvector_ostream os(buf);
+        to_ubjson(os, j, use_size, use_type);
+        return os.array();
     }
 //-------EXPORTED_FUNC_CONTENTS_END
 //-------EXPORTED_FUNC_DEF_START json
-    static void to_ubjson(const basic_json& j, detail::output_adapter<char> o,
+    static std::span<uint8_t> to_ubjson(const basic_json& j, SmallVectorImpl<uint8_t>& buf,
                           const bool use_size = false, const bool use_type = false)
 //-------EXPORTED_FUNC_DEF_END
 //-------EXPORTED_FUNC_CONTENTS_START
     {
-        binary_writer<char>(o).write_ubjson(j, use_size, use_type);
+        buf.clear();
+        raw_usvector_ostream os(buf);
+        to_ubjson(os, j, use_size, use_type);
+        return os.array();
+    }
+//-------EXPORTED_FUNC_CONTENTS_END
+
+//-------EXPORTED_FUNC_DEF_START json
+    static void to_ubjson(raw_ostream& os, const json& j,
+                        const bool use_size = false, const bool use_type = false)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
+    {
+        binary_writer(os).write_ubjson(j, use_size, use_type);
     }
 //-------EXPORTED_FUNC_CONTENTS_END
 
@@ -6809,9 +6884,9 @@ class basic_json
 
     @sa http://cbor.io
     @sa @ref to_cbor(const basic_json&) for the analogous serialization
-    @sa @ref from_msgpack(detail::input_adapter, const bool, const bool) for the
+    @sa @ref from_msgpack(raw_istream&, const bool, const bool) for the
         related MessagePack format
-    @sa @ref from_ubjson(detail::input_adapter, const bool, const bool) for the
+    @sa @ref from_ubjson(raw_istream&, const bool, const bool) for the
         related UBJSON format
 
     @since version 2.0.9; parameter @a start_index since 2.1.1; changed to
@@ -6820,7 +6895,7 @@ class basic_json
            since 3.2.0
     */
 //-------EXPORTED_FUNC_DEF_START json
-    static basic_json from_cbor(detail::input_adapter&& i,
+    static basic_json from_cbor(raw_istream& i,
                                 const bool strict = true,
                                 const bool allow_exceptions = true)
 //-------EXPORTED_FUNC_DEF_END
@@ -6834,19 +6909,19 @@ class basic_json
 //-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
-    @copydoc from_cbor(detail::input_adapter, const bool, const bool)
+    @copydoc from_cbor(raw_istream, const bool, const bool)
     */
-    template<typename A1, typename A2,
-             detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
-    static basic_json from_cbor(A1 && a1, A2 && a2,
-                                const bool strict = true,
-                                const bool allow_exceptions = true)
+//-------EXPORTED_FUNC_DEF_START json
+    static json from_cbor(std::span<const uint8_t> arr, const bool strict = true)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         basic_json result;
         detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
         const bool res = binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).sax_parse(input_format_t::cbor, &sdp, strict);
         return res ? result : basic_json(value_t::discarded);
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief create a JSON value from an input in MessagePack format
@@ -6916,9 +6991,9 @@ class basic_json
 
     @sa http://msgpack.org
     @sa @ref to_msgpack(const basic_json&) for the analogous serialization
-    @sa @ref from_cbor(detail::input_adapter, const bool, const bool) for the
+    @sa @ref from_cbor(raw_istream&, const bool, const bool) for the
         related CBOR format
-    @sa @ref from_ubjson(detail::input_adapter, const bool, const bool) for
+    @sa @ref from_ubjson(raw_istream&, const bool, const bool) for
         the related UBJSON format
 
     @since version 2.0.9; parameter @a start_index since 2.1.1; changed to
@@ -6927,7 +7002,7 @@ class basic_json
            since 3.2.0
     */
 //-------EXPORTED_FUNC_DEF_START json
-    static basic_json from_msgpack(detail::input_adapter&& i,
+    static basic_json from_msgpack(raw_istream&& is,
                                    const bool strict = true,
                                    const bool allow_exceptions = true)
 //-------EXPORTED_FUNC_DEF_END
@@ -6940,21 +7015,6 @@ class basic_json
     }
 //-------EXPORTED_FUNC_CONTENTS_END
 
-    /*!
-    @copydoc from_msgpack(detail::input_adapter, const bool, const bool)
-    */
-    template<typename A1, typename A2,
-             detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
-    static basic_json from_msgpack(A1 && a1, A2 && a2,
-                                   const bool strict = true,
-                                   const bool allow_exceptions = true)
-    {
-        basic_json result;
-        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
-        const bool res = binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).sax_parse(input_format_t::msgpack, &sdp, strict);
-        return res ? result : basic_json(value_t::discarded);
-    }
-
     /*!
     @brief create a JSON value from an input in UBJSON format
 
@@ -7005,15 +7065,15 @@ class basic_json
     @sa http://ubjson.org
     @sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
              analogous serialization
-    @sa @ref from_cbor(detail::input_adapter, const bool, const bool) for the
+    @sa @ref from_cbor(raw_istream&, const bool, const bool) for the
         related CBOR format
-    @sa @ref from_msgpack(detail::input_adapter, const bool, const bool) for
+    @sa @ref from_msgpack(raw_istream&, const bool, const bool) for
         the related MessagePack format
 
     @since version 3.1.0; added @allow_exceptions parameter since 3.2.0
     */
 //-------EXPORTED_FUNC_DEF_START json
-    static basic_json from_ubjson(detail::input_adapter&& i,
+    static basic_json from_ubjson(raw_istream& is,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
 //-------EXPORTED_FUNC_DEF_END
@@ -7026,20 +7086,15 @@ class basic_json
     }
 //-------EXPORTED_FUNC_CONTENTS_END
 
-    /*!
-    @copydoc from_ubjson(detail::input_adapter, const bool, const bool)
-    */
-    template<typename A1, typename A2,
-             detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
-    static basic_json from_ubjson(A1 && a1, A2 && a2,
-                                  const bool strict = true,
-                                  const bool allow_exceptions = true)
+//-------EXPORTED_FUNC_DEF_START json
+    static json from_ubjson(std::span<const uint8_t> arr, const bool strict = true)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
-        basic_json result;
-        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
-        const bool res = binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).sax_parse(input_format_t::ubjson, &sdp, strict);
-        return res ? result : basic_json(value_t::discarded);
+        raw_mem_istream is(arr);
+        return from_ubjson(is, strict);
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /// @}
 
@@ -7703,7 +7758,7 @@ class basic_json
                     for (auto it = source.cbegin(); it != source.cend(); ++it)
                     {
                         // escape the key name to be used in a JSON patch
-                        const auto key = json_pointer::escape(it.key());
+                        const auto key = json_pointer::escape(std::string{it.key()});
 
                         if (target.find(it.key()) != target.end())
                         {
@@ -7727,7 +7782,7 @@ class basic_json
                         if (source.find(it.key()) == source.end())
                         {
                             // found a key that is not in this -> add it
-                            const auto key = json_pointer::escape(it.key());
+                            const auto key = json_pointer::escape(std::string{it.key()});
                             result.push_back(
                             {
                                 {"op", "add"}, {"path", path + "/" + key},
@@ -7913,7 +7968,7 @@ if no parse error occurred.
 */
 inline nlohmann::json operator "" _json(const char* s, std::size_t n)
 {
-    return nlohmann::json::parse(s, s + n);
+    return nlohmann::json::parse(std::string_view(s, n));
 }
 
 /*!
@@ -7931,7 +7986,7 @@ object if no parse error occurred.
 */
 inline nlohmann::json::json_pointer operator "" _json_pointer(const char* s, std::size_t n)
 {
-    return nlohmann::json::json_pointer(std::string(s, n));
+    return nlohmann::json::json_pointer(std::string_view(s, n));
 }
 
 #include <nlohmann/detail/macro_unscope.hpp>
