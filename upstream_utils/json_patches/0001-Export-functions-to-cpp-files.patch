From 6ffeee21157844a44bb0247a1521927a0e23a05c Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Mon, 19 Dec 2022 03:13:12 -0500
Subject: [PATCH 01/12] Export functions to cpp files

---
 include/nlohmann/detail/exceptions.hpp        |  27 +-
 .../nlohmann/detail/input/binary_reader.hpp   |  84 ++++++
 include/nlohmann/detail/input/json_sax.hpp    |  36 +++
 include/nlohmann/detail/input/lexer.hpp       |  52 ++++
 include/nlohmann/detail/input/parser.hpp      |  16 ++
 include/nlohmann/detail/json_pointer.hpp      |  60 ++++
 .../nlohmann/detail/output/binary_writer.hpp  |  32 +++
 include/nlohmann/detail/output/serializer.hpp |  16 ++
 include/nlohmann/json.hpp                     | 262 +++++++++++++++++-
 9 files changed, 577 insertions(+), 8 deletions(-)

diff --git a/include/nlohmann/detail/exceptions.hpp b/include/nlohmann/detail/exceptions.hpp
index b73d7b1f..ef6f8374 100644
--- a/include/nlohmann/detail/exceptions.hpp
+++ b/include/nlohmann/detail/exceptions.hpp
@@ -53,7 +53,12 @@ class exception : public std::exception
     const int id;
 
   protected:
-    exception(int id_, const char* what_arg) : id(id_), m(what_arg) {}
+//-------EXPORTED_FUNC_DEF_START exception
+    exception(int id_, const char* what_arg)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
+ : id(id_), m(what_arg) {}
+//-------EXPORTED_FUNC_CONTENTS_END
 
     static std::string name(const std::string& ename, int id_)
     {
@@ -119,13 +124,17 @@ class parse_error : public exception
     @param[in] what_arg  the explanatory string
     @return parse_error object
     */
+//-------EXPORTED_FUNC_DEF_START parse_error
     static parse_error create(int id_, std::size_t byte_, const std::string& what_arg)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         std::string w = exception::name("parse_error", id_) + "parse error" +
                         (byte_ != 0 ? (" at " + std::to_string(byte_)) : "") +
                         ": " + what_arg;
         return parse_error(id_, byte_, w.c_str());
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief byte index of the parse error
@@ -183,11 +192,15 @@ caught.,invalid_iterator}
 class invalid_iterator : public exception
 {
   public:
+//-------EXPORTED_FUNC_DEF_START invalid_iterator
     static invalid_iterator create(int id_, const std::string& what_arg)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         std::string w = exception::name("invalid_iterator", id_) + what_arg;
         return invalid_iterator(id_, w.c_str());
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
   private:
     invalid_iterator(int id_, const char* what_arg)
@@ -235,11 +248,15 @@ caught.,type_error}
 class type_error : public exception
 {
   public:
+//-------EXPORTED_FUNC_DEF_START type_error
     static type_error create(int id_, const std::string& what_arg)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         std::string w = exception::name("type_error", id_) + what_arg;
         return type_error(id_, w.c_str());
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
   private:
     type_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
@@ -280,11 +297,15 @@ caught.,out_of_range}
 class out_of_range : public exception
 {
   public:
+//-------EXPORTED_FUNC_DEF_START out_of_range
     static out_of_range create(int id_, const std::string& what_arg)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         std::string w = exception::name("out_of_range", id_) + what_arg;
         return out_of_range(id_, w.c_str());
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
   private:
     out_of_range(int id_, const char* what_arg) : exception(id_, what_arg) {}
@@ -317,11 +338,15 @@ caught.,other_error}
 class other_error : public exception
 {
   public:
+//-------EXPORTED_FUNC_DEF_START other_error
     static other_error create(int id_, const std::string& what_arg)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         std::string w = exception::name("other_error", id_) + what_arg;
         return other_error(id_, w.c_str());
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
   private:
     other_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
diff --git a/include/nlohmann/detail/input/binary_reader.hpp b/include/nlohmann/detail/input/binary_reader.hpp
index 05ab36f3..df6bb3b0 100644
--- a/include/nlohmann/detail/input/binary_reader.hpp
+++ b/include/nlohmann/detail/input/binary_reader.hpp
@@ -59,9 +59,12 @@ class binary_reader
 
     @return
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     bool sax_parse(const input_format_t format,
                    json_sax_t* sax_,
                    const bool strict = true)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         sax = sax_;
         bool result = false;
@@ -106,6 +109,7 @@ class binary_reader
 
         return result;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief determine system byte order
@@ -127,7 +131,10 @@ class binary_reader
 
     @return whether a valid CBOR value was passed to the SAX parser
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     bool parse_cbor_internal(const bool get_char = true)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         switch (get_char ? get() : current)
         {
@@ -454,11 +461,15 @@ class binary_reader
             }
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @return whether a valid MessagePack value was passed to the SAX parser
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     bool parse_msgpack_internal()
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         switch (get())
         {
@@ -816,6 +827,7 @@ class binary_reader
             }
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @param[in] get_char  whether a new character should be retrieved from the
@@ -838,16 +850,23 @@ class binary_reader
 
     @return character read from the input
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     int get()
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         ++chars_read;
         return (current = ia->get_character());
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @return character read from the input after ignoring all 'N' entries
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     int get_ignore_noop()
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         do
         {
@@ -857,6 +876,7 @@ class binary_reader
 
         return current;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*
     @brief read a number from the input
@@ -870,8 +890,11 @@ class binary_reader
           bytes in CBOR, MessagePack, and UBJSON are stored in network order
           (big endian) and therefore need reordering on little endian systems.
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     template<typename NumberType>
     bool get_number(NumberType& result)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // step 1: read input into array with system's byte order
         std::array<uint8_t, sizeof(NumberType)> vec;
@@ -898,6 +921,7 @@ class binary_reader
         std::memcpy(&result, vec.data(), sizeof(NumberType));
         return true;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief create a string by reading characters from the input
@@ -912,8 +936,11 @@ class binary_reader
           may be too large. Usually, @ref unexpect_eof() detects the end of
           the input before we run out of string memory.
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     template<typename NumberType>
     bool get_string(const NumberType len, string_t& result)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         bool success = true;
         std::generate_n(std::back_inserter(result), len, [this, &success]()
@@ -927,6 +954,7 @@ class binary_reader
         });
         return success;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief reads a CBOR string
@@ -939,7 +967,10 @@ class binary_reader
 
     @return whether string creation completed
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     bool get_cbor_string(string_t& result)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (JSON_UNLIKELY(not unexpect_eof()))
         {
@@ -1022,13 +1053,17 @@ class binary_reader
             }
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @param[in] len  the length of the array or std::size_t(-1) for an
                     array of indefinite size
     @return whether array creation completed
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     bool get_cbor_array(const std::size_t len)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (JSON_UNLIKELY(not sax->start_array(len)))
         {
@@ -1056,13 +1091,17 @@ class binary_reader
 
         return sax->end_array();
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @param[in] len  the length of the object or std::size_t(-1) for an
                     object of indefinite size
     @return whether object creation completed
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     bool get_cbor_object(const std::size_t len)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (not JSON_UNLIKELY(sax->start_object(len)))
         {
@@ -1106,6 +1145,7 @@ class binary_reader
 
         return sax->end_object();
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief reads a MessagePack string
@@ -1117,7 +1157,10 @@ class binary_reader
 
     @return whether string creation completed
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     bool get_msgpack_string(string_t& result)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (JSON_UNLIKELY(not unexpect_eof()))
         {
@@ -1188,12 +1231,16 @@ class binary_reader
             }
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     /*!
     @param[in] len  the length of the array
     @return whether array creation completed
     */
     bool get_msgpack_array(const std::size_t len)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (JSON_UNLIKELY(not sax->start_array(len)))
         {
@@ -1210,12 +1257,16 @@ class binary_reader
 
         return sax->end_array();
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @param[in] len  the length of the object
     @return whether object creation completed
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     bool get_msgpack_object(const std::size_t len)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (JSON_UNLIKELY(not sax->start_object(len)))
         {
@@ -1240,6 +1291,7 @@ class binary_reader
 
         return sax->end_object();
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief reads a UBJSON string
@@ -1255,7 +1307,10 @@ class binary_reader
 
     @return whether string creation completed
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     bool get_ubjson_string(string_t& result, const bool get_char = true)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (get_char)
         {
@@ -1304,12 +1359,16 @@ class binary_reader
                 return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, "expected a UBJSON string; last byte: 0x" + last_token));
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @param[out] result  determined size
     @return whether size determination completed
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     bool get_ubjson_size_value(std::size_t& result)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         switch (get_ignore_noop())
         {
@@ -1375,6 +1434,7 @@ class binary_reader
             }
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief determine the type and size for a container
@@ -1386,7 +1446,10 @@ class binary_reader
 
     @return whether pair creation completed
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     bool get_ubjson_size_type(std::pair<std::size_t, int>& result)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         result.first = string_t::npos; // size
         result.second = 0; // type
@@ -1420,12 +1483,16 @@ class binary_reader
         }
         return true;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @param prefix  the previously read or set type prefix
     @return whether value creation completed
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     bool get_ubjson_value(const int prefix)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         switch (prefix)
         {
@@ -1517,11 +1584,15 @@ class binary_reader
             }
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @return whether array creation completed
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     bool get_ubjson_array()
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         std::pair<std::size_t, int> size_and_type;
         if (JSON_UNLIKELY(not get_ubjson_size_type(size_and_type)))
@@ -1579,11 +1650,15 @@ class binary_reader
 
         return sax->end_array();
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @return whether object creation completed
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     bool get_ubjson_object()
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         std::pair<std::size_t, int> size_and_type;
         if (JSON_UNLIKELY(not get_ubjson_size_type(size_and_type)))
@@ -1654,11 +1729,15 @@ class binary_reader
 
         return sax->end_object();
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @return whether the last read character is not EOF
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     bool unexpect_eof() const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (JSON_UNLIKELY(current == std::char_traits<char>::eof()))
         {
@@ -1666,16 +1745,21 @@ class binary_reader
         }
         return true;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @return a string representation of the last read byte
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_reader
     std::string get_token_string() const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         char cr[3];
         snprintf(cr, 3, "%.2hhX", static_cast<unsigned char>(current));
         return std::string{cr};
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
   private:
     /// input adapter
diff --git a/include/nlohmann/detail/input/json_sax.hpp b/include/nlohmann/detail/input/json_sax.hpp
index 1705a861..5278b8bd 100644
--- a/include/nlohmann/detail/input/json_sax.hpp
+++ b/include/nlohmann/detail/input/json_sax.hpp
@@ -193,7 +193,10 @@ class json_sax_dom_parser
         return true;
     }
 
+//-------EXPORTED_FUNC_DEF_START json_sax_dom_parser
     bool start_object(std::size_t len)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         ref_stack.push_back(handle_value(BasicJsonType::value_t::object));
 
@@ -205,6 +208,7 @@ class json_sax_dom_parser
 
         return true;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     bool key(string_t& val)
     {
@@ -219,7 +223,10 @@ class json_sax_dom_parser
         return true;
     }
 
+//-------EXPORTED_FUNC_DEF_START json_sax_dom_parser
     bool start_array(std::size_t len)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         ref_stack.push_back(handle_value(BasicJsonType::value_t::array));
 
@@ -231,6 +238,7 @@ class json_sax_dom_parser
 
         return true;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     bool end_array()
     {
@@ -238,8 +246,11 @@ class json_sax_dom_parser
         return true;
     }
 
+//-------EXPORTED_FUNC_DEF_START json_sax_dom_parser
     bool parse_error(std::size_t, const std::string&,
                      const detail::exception& ex)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         errored = true;
         if (allow_exceptions)
@@ -265,6 +276,7 @@ class json_sax_dom_parser
         }
         return false;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     constexpr bool is_errored() const
     {
@@ -370,7 +382,10 @@ class json_sax_dom_callback_parser
         return true;
     }
 
+//-------EXPORTED_FUNC_DEF_START json_sax_dom_callback_parser
     bool start_object(std::size_t len)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // check callback for object start
         const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::object_start, discarded);
@@ -391,8 +406,12 @@ class json_sax_dom_callback_parser
 
         return true;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
+//-------EXPORTED_FUNC_DEF_START json_sax_dom_callback_parser
     bool key(string_t& val)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         BasicJsonType k = BasicJsonType(val);
 
@@ -408,8 +427,12 @@ class json_sax_dom_callback_parser
 
         return true;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
+//-------EXPORTED_FUNC_DEF_START json_sax_dom_callback_parser
     bool end_object()
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (ref_stack.back())
         {
@@ -443,8 +466,12 @@ class json_sax_dom_callback_parser
 
         return true;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
+//-------EXPORTED_FUNC_DEF_START json_sax_dom_callback_parser
     bool start_array(std::size_t len)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::array_start, discarded);
         keep_stack.push_back(keep);
@@ -464,8 +491,12 @@ class json_sax_dom_callback_parser
 
         return true;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
+//-------EXPORTED_FUNC_DEF_START json_sax_dom_callback_parser
     bool end_array()
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         bool keep = true;
 
@@ -495,9 +526,13 @@ class json_sax_dom_callback_parser
 
         return true;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
+//-------EXPORTED_FUNC_DEF_START json_sax_dom_callback_parser
     bool parse_error(std::size_t, const std::string&,
                      const detail::exception& ex)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         errored = true;
         if (allow_exceptions)
@@ -523,6 +558,7 @@ class json_sax_dom_callback_parser
         }
         return false;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     constexpr bool is_errored() const
     {
diff --git a/include/nlohmann/detail/input/lexer.hpp b/include/nlohmann/detail/input/lexer.hpp
index 44165ff0..0cc9a8c1 100644
--- a/include/nlohmann/detail/input/lexer.hpp
+++ b/include/nlohmann/detail/input/lexer.hpp
@@ -56,7 +56,10 @@ class lexer
     };
 
     /// return name of values of type token_type (only used for errors)
+//-------EXPORTED_FUNC_DEF_START json::lexer
     static const char* token_type_name(const token_type t) noexcept
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         switch (t)
         {
@@ -98,9 +101,14 @@ class lexer
                 // LCOV_EXCL_STOP
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
+//-------EXPORTED_FUNC_DEF_START json::lexer
     explicit lexer(detail::input_adapter_t&& adapter)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
         : ia(std::move(adapter)), decimal_point_char(get_decimal_point()) {}
+//-------EXPORTED_FUNC_CONTENTS_END
 
     // delete because of pointer members
     lexer(const lexer&) = delete;
@@ -138,7 +146,10 @@ class lexer
     @return codepoint (0x0000..0xFFFF) or -1 in case of an error (e.g. EOF or
             non-hex character)
     */
+//-------EXPORTED_FUNC_DEF_START json::lexer
     int get_codepoint()
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // this function only makes sense after reading `\u`
         assert(current == 'u');
@@ -170,6 +181,7 @@ class lexer
         assert(0x0000 <= codepoint and codepoint <= 0xFFFF);
         return codepoint;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief check if the next byte(s) are inside a given range
@@ -186,7 +198,10 @@ class lexer
 
     @return true if and only if no range violation was detected
     */
+//-------EXPORTED_FUNC_DEF_START json::lexer
     bool next_byte_in_range(std::initializer_list<int> ranges)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         assert(ranges.size() == 2 or ranges.size() == 4 or ranges.size() == 6);
         add(current);
@@ -207,6 +222,7 @@ class lexer
 
         return true;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief scan a string literal
@@ -223,7 +239,10 @@ class lexer
     @note In case of errors, variable error_message contains a textual
           description.
     */
+//-------EXPORTED_FUNC_DEF_START json::lexer
     token_type scan_string()
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // reset token_buffer (ignore opening quote)
         reset();
@@ -653,6 +672,7 @@ class lexer
             }
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     static void strtof(float& f, const char* str, char** endptr) noexcept
     {
@@ -709,7 +729,10 @@ class lexer
           locale's decimal point is used instead of `.` to work with the
           locale-dependent converters.
     */
+//-------EXPORTED_FUNC_DEF_START json::lexer
     token_type scan_number()
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // reset token_buffer to store the number's bytes
         reset();
@@ -1037,14 +1060,18 @@ scan_number_done:
 
         return token_type::value_float;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @param[in] literal_text  the literal text to expect
     @param[in] length        the length of the passed literal text
     @param[in] return_type   the token type to return on success
     */
+//-------EXPORTED_FUNC_DEF_START json::lexer
     token_type scan_literal(const char* literal_text, const std::size_t length,
                             token_type return_type)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         assert(current == literal_text[0]);
         for (std::size_t i = 1; i < length; ++i)
@@ -1057,18 +1084,23 @@ scan_number_done:
         }
         return return_type;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /////////////////////
     // input management
     /////////////////////
 
     /// reset token_buffer; current character is beginning of token
+//-------EXPORTED_FUNC_DEF_START json::lexer
     void reset() noexcept
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         token_buffer.clear();
         token_string.clear();
         token_string.push_back(std::char_traits<char>::to_char_type(current));
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*
     @brief get next character from the input
@@ -1080,7 +1112,10 @@ scan_number_done:
 
     @return character read from the input
     */
+//-------EXPORTED_FUNC_DEF_START json::lexer
     std::char_traits<char>::int_type get()
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         ++chars_read;
         if (next_unget)
@@ -1099,6 +1134,7 @@ scan_number_done:
         }
         return current;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief unget current character (read it again on next get)
@@ -1108,7 +1144,10 @@ scan_number_done:
     token_string. The next call to get() will behave as if the unget character
     is read again.
     */
+//-------EXPORTED_FUNC_DEF_START json::lexer
     void unget()
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         next_unget = true;
         --chars_read;
@@ -1118,6 +1157,7 @@ scan_number_done:
             token_string.pop_back();
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /// add a character to token_buffer
     void add(int c)
@@ -1167,7 +1207,10 @@ scan_number_done:
     /// return the last read token (for errors only).  Will never contain EOF
     /// (an arbitrary value that is not a valid char value, often -1), because
     /// 255 may legitimately occur.  May contain NUL, which should be escaped.
+//-------EXPORTED_FUNC_DEF_START json::lexer
     std::string get_token_string() const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // escape control characters
         std::string result;
@@ -1189,6 +1232,7 @@ scan_number_done:
 
         return result;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /// return syntax error message
     constexpr const char* get_error_message() const noexcept
@@ -1204,7 +1248,10 @@ scan_number_done:
     @brief skip the UTF-8 byte order mark
     @return true iff there is no BOM or the correct BOM has been skipped
     */
+//-------EXPORTED_FUNC_DEF_START json::lexer
     bool skip_bom()
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (get() == 0xEF)
         {
@@ -1227,8 +1274,12 @@ scan_number_done:
             return true;
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
+//-------EXPORTED_FUNC_DEF_START json::lexer
     token_type scan()
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // initially, skip the BOM
         if (chars_read == 0 and not skip_bom())
@@ -1298,6 +1349,7 @@ scan_number_done:
                 return token_type::parse_error;
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
   private:
     /// input adapter
diff --git a/include/nlohmann/detail/input/parser.hpp b/include/nlohmann/detail/input/parser.hpp
index 70d92a26..6177a1e0 100644
--- a/include/nlohmann/detail/input/parser.hpp
+++ b/include/nlohmann/detail/input/parser.hpp
@@ -78,7 +78,10 @@ class parser
     @throw parse_error.102 if to_unicode fails or surrogate error
     @throw parse_error.103 if to_unicode fails
     */
+//-------EXPORTED_FUNC_DEF_START json::parser
     void parse(const bool strict, BasicJsonType& result)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (callback)
         {
@@ -130,6 +133,7 @@ class parser
             }
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief public accept interface
@@ -137,7 +141,10 @@ class parser
     @param[in] strict  whether to expect the last token to be EOF
     @return whether the input is a proper JSON text
     */
+//-------EXPORTED_FUNC_DEF_START json::parser
     bool accept(const bool strict = true)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         json_sax_acceptor<BasicJsonType> sax_acceptor;
         return sax_parse(&sax_acceptor, strict);
@@ -159,10 +166,14 @@ class parser
 
         return result;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
   private:
+//-------EXPORTED_FUNC_DEF_START json::parser
     template <typename SAX>
     bool sax_parse_internal(SAX* sax)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // stack to remember the hieararchy of structured values we are parsing
         // true = array; false = object
@@ -446,6 +457,7 @@ class parser
             }
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /// get next token from lexer
     token_type get_token()
@@ -453,7 +465,10 @@ class parser
         return (last_token = m_lexer.scan());
     }
 
+//-------EXPORTED_FUNC_DEF_START json::parser
     std::string exception_message(const token_type expected)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         std::string error_msg = "syntax error - ";
         if (last_token == token_type::parse_error)
@@ -473,6 +488,7 @@ class parser
 
         return error_msg;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
   private:
     /// callback function
diff --git a/include/nlohmann/detail/json_pointer.hpp b/include/nlohmann/detail/json_pointer.hpp
index fce8001a..ea99b602 100644
--- a/include/nlohmann/detail/json_pointer.hpp
+++ b/include/nlohmann/detail/json_pointer.hpp
@@ -59,7 +59,10 @@ class json_pointer
 
     @since version 2.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json_pointer
     std::string to_string() const noexcept
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         return std::accumulate(reference_tokens.begin(), reference_tokens.end(),
                                std::string{},
@@ -68,6 +71,7 @@ class json_pointer
             return a + "/" + escape(b);
         });
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /// @copydoc to_string()
     operator std::string() const
@@ -82,7 +86,10 @@ class json_pointer
 
     @throw out_of_range.404 if string @a s could not be converted to an integer
     */
+//-------EXPORTED_FUNC_DEF_START json_pointer
     static int array_index(const std::string& s)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         std::size_t processed_chars = 0;
         const int res = std::stoi(s, &processed_chars);
@@ -95,13 +102,17 @@ class json_pointer
 
         return res;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
   private:
     /*!
     @brief remove and return last reference pointer
     @throw out_of_range.405 if JSON pointer has no parent
     */
+//-------EXPORTED_FUNC_DEF_START json_pointer
     std::string pop_back()
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (JSON_UNLIKELY(is_root()))
         {
@@ -112,6 +123,7 @@ class json_pointer
         reference_tokens.pop_back();
         return last;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /// return whether pointer points to the root document
     bool is_root() const
@@ -119,7 +131,10 @@ class json_pointer
         return reference_tokens.empty();
     }
 
+//-------EXPORTED_FUNC_DEF_START json_pointer
     json_pointer top() const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (JSON_UNLIKELY(is_root()))
         {
@@ -130,6 +145,7 @@ class json_pointer
         result.reference_tokens = {reference_tokens[0]};
         return result;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief create and return a reference to the pointed to value
@@ -139,7 +155,10 @@ class json_pointer
     @throw parse_error.109 if array index is not a number
     @throw type_error.313 if value cannot be unflattened
     */
+//-------EXPORTED_FUNC_DEF_START json_pointer
     BasicJsonType& get_and_create(BasicJsonType& j) const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         using size_type = typename BasicJsonType::size_type;
         auto result = &j;
@@ -199,6 +218,7 @@ class json_pointer
 
         return *result;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief return a reference to the pointed to value
@@ -219,7 +239,10 @@ class json_pointer
     @throw parse_error.109   if an array index was not a number
     @throw out_of_range.404  if the JSON pointer can not be resolved
     */
+//-------EXPORTED_FUNC_DEF_START json_pointer
     BasicJsonType& get_unchecked(BasicJsonType* ptr) const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         using size_type = typename BasicJsonType::size_type;
         for (const auto& reference_token : reference_tokens)
@@ -288,6 +311,7 @@ class json_pointer
 
         return *ptr;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @throw parse_error.106   if an array index begins with '0'
@@ -295,7 +319,10 @@ class json_pointer
     @throw out_of_range.402  if the array index '-' is used
     @throw out_of_range.404  if the JSON pointer can not be resolved
     */
+//-------EXPORTED_FUNC_DEF_START json_pointer
     BasicJsonType& get_checked(BasicJsonType* ptr) const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         using size_type = typename BasicJsonType::size_type;
         for (const auto& reference_token : reference_tokens)
@@ -346,6 +373,7 @@ class json_pointer
 
         return *ptr;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief return a const reference to the pointed to value
@@ -360,7 +388,10 @@ class json_pointer
     @throw out_of_range.402  if the array index '-' is used
     @throw out_of_range.404  if the JSON pointer can not be resolved
     */
+//-------EXPORTED_FUNC_DEF_START json_pointer
     const BasicJsonType& get_unchecked(const BasicJsonType* ptr) const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         using size_type = typename BasicJsonType::size_type;
         for (const auto& reference_token : reference_tokens)
@@ -412,6 +443,7 @@ class json_pointer
 
         return *ptr;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @throw parse_error.106   if an array index begins with '0'
@@ -419,7 +451,10 @@ class json_pointer
     @throw out_of_range.402  if the array index '-' is used
     @throw out_of_range.404  if the JSON pointer can not be resolved
     */
+//-------EXPORTED_FUNC_DEF_START json_pointer
     const BasicJsonType& get_checked(const BasicJsonType* ptr) const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         using size_type = typename BasicJsonType::size_type;
         for (const auto& reference_token : reference_tokens)
@@ -470,6 +505,7 @@ class json_pointer
 
         return *ptr;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief split the string input to reference tokens
@@ -480,7 +516,10 @@ class json_pointer
     @throw parse_error.107  if the pointer is not empty or begins with '/'
     @throw parse_error.108  if character '~' is not followed by '0' or '1'
     */
+//-------EXPORTED_FUNC_DEF_START json_pointer
     static std::vector<std::string> split(const std::string& reference_string)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         std::vector<std::string> result;
 
@@ -541,6 +580,7 @@ class json_pointer
 
         return result;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief replace all occurrences of a substring by another string
@@ -555,8 +595,11 @@ class json_pointer
 
     @since version 2.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json_pointer
     static void replace_substring(std::string& s, const std::string& f,
                                   const std::string& t)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         assert(not f.empty());
         for (auto pos = s.find(f);                // find first occurrence of f
@@ -565,21 +608,30 @@ class json_pointer
                 pos = s.find(f, pos + t.size()))  // find next occurrence of f
         {}
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /// escape "~"" to "~0" and "/" to "~1"
+//-------EXPORTED_FUNC_DEF_START json_pointer
     static std::string escape(std::string s)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         replace_substring(s, "~", "~0");
         replace_substring(s, "/", "~1");
         return s;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /// unescape "~1" to tilde and "~0" to slash (order is important!)
+//-------EXPORTED_FUNC_DEF_START json_pointer
     static void unescape(std::string& s)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         replace_substring(s, "~1", "/");
         replace_substring(s, "~0", "~");
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @param[in] reference_string  the reference string to the current value
@@ -588,9 +640,12 @@ class json_pointer
 
     @note Empty objects or arrays are flattened to `null`.
     */
+//-------EXPORTED_FUNC_DEF_START json_pointer
     static void flatten(const std::string& reference_string,
                         const BasicJsonType& value,
                         BasicJsonType& result)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         switch (value.m_type)
         {
@@ -639,6 +694,7 @@ class json_pointer
             }
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @param[in] value  flattened JSON
@@ -650,8 +706,11 @@ class json_pointer
     @throw type_error.315  if object values are not primitive
     @throw type_error.313  if value cannot be unflattened
     */
+//-------EXPORTED_FUNC_DEF_START json_pointer
     static BasicJsonType
     unflatten(const BasicJsonType& value)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (JSON_UNLIKELY(not value.is_object()))
         {
@@ -677,6 +736,7 @@ class json_pointer
 
         return result;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     friend bool operator==(json_pointer const& lhs,
                            json_pointer const& rhs) noexcept
diff --git a/include/nlohmann/detail/output/binary_writer.hpp b/include/nlohmann/detail/output/binary_writer.hpp
index 71e5ec81..5c2aa9ce 100644
--- a/include/nlohmann/detail/output/binary_writer.hpp
+++ b/include/nlohmann/detail/output/binary_writer.hpp
@@ -37,7 +37,10 @@ class binary_writer
     /*!
     @brief[in] j  JSON value to serialize
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_writer
     void write_cbor(const BasicJsonType& j)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         switch (j.type())
         {
@@ -277,11 +280,15 @@ class binary_writer
                 break;
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief[in] j  JSON value to serialize
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_writer
     void write_msgpack(const BasicJsonType& j)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         switch (j.type())
         {
@@ -516,6 +523,7 @@ class binary_writer
                 break;
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @param[in] j  JSON value to serialize
@@ -523,8 +531,11 @@ class binary_writer
     @param[in] use_type    whether to use '$' prefixes (optimized format)
     @param[in] add_prefix  whether prefixes need to be used for this value
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_writer
     void write_ubjson(const BasicJsonType& j, const bool use_count,
                       const bool use_type, const bool add_prefix = true)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         switch (j.type())
         {
@@ -675,6 +686,7 @@ class binary_writer
                 break;
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
   private:
     /*
@@ -687,8 +699,11 @@ class binary_writer
           in CBOR, MessagePack, and UBJSON are stored in network order (big
           endian) and therefore need reordering on little endian systems.
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_writer
     template<typename NumberType>
     void write_number(const NumberType n)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // step 1: write number to array of length NumberType
         std::array<CharType, sizeof(NumberType)> vec;
@@ -703,12 +718,16 @@ class binary_writer
 
         oa->write_characters(vec.data(), sizeof(NumberType));
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     // UBJSON: write number (floating point)
+//-------EXPORTED_FUNC_DEF_START json::binary_writer
     template<typename NumberType, typename std::enable_if<
                  std::is_floating_point<NumberType>::value, int>::type = 0>
     void write_number_with_ubjson_prefix(const NumberType n,
                                          const bool add_prefix)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (add_prefix)
         {
@@ -716,12 +735,16 @@ class binary_writer
         }
         write_number(n);
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     // UBJSON: write number (unsigned integer)
+//-------EXPORTED_FUNC_DEF_START json::binary_writer
     template<typename NumberType, typename std::enable_if<
                  std::is_unsigned<NumberType>::value, int>::type = 0>
     void write_number_with_ubjson_prefix(const NumberType n,
                                          const bool add_prefix)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (n <= static_cast<uint64_t>((std::numeric_limits<int8_t>::max)()))
         {
@@ -768,13 +791,17 @@ class binary_writer
             JSON_THROW(out_of_range::create(407, "number overflow serializing " + std::to_string(n)));
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     // UBJSON: write number (signed integer)
+//-------EXPORTED_FUNC_DEF_START json::binary_writer
     template<typename NumberType, typename std::enable_if<
                  std::is_signed<NumberType>::value and
                  not std::is_floating_point<NumberType>::value, int>::type = 0>
     void write_number_with_ubjson_prefix(const NumberType n,
                                          const bool add_prefix)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if ((std::numeric_limits<int8_t>::min)() <= n and n <= (std::numeric_limits<int8_t>::max)())
         {
@@ -823,6 +850,7 @@ class binary_writer
         }
         // LCOV_EXCL_STOP
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief determine the type prefix of container values
@@ -833,7 +861,10 @@ class binary_writer
           write_number_with_ubjson_prefix. Therefore, we return 'L' for any
           value that does not fit the previous limits.
     */
+//-------EXPORTED_FUNC_DEF_START json::binary_writer
     CharType ubjson_prefix(const BasicJsonType& j) const noexcept
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         switch (j.type())
         {
@@ -907,6 +938,7 @@ class binary_writer
                 return 'N';
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     static constexpr CharType get_cbor_float_prefix(float)
     {
diff --git a/include/nlohmann/detail/output/serializer.hpp b/include/nlohmann/detail/output/serializer.hpp
index e2655f04..be1545b6 100644
--- a/include/nlohmann/detail/output/serializer.hpp
+++ b/include/nlohmann/detail/output/serializer.hpp
@@ -71,10 +71,13 @@ class serializer
     @param[in] indent_step     the indent level
     @param[in] current_indent  the current indent level (only used internally)
     */
+//-------EXPORTED_FUNC_DEF_START json::serializer
     void dump(const BasicJsonType& val, const bool pretty_print,
               const bool ensure_ascii,
               const unsigned int indent_step,
               const unsigned int current_indent = 0)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         switch (val.m_type)
         {
@@ -262,6 +265,7 @@ class serializer
             }
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
   private:
     /*!
@@ -278,7 +282,10 @@ class serializer
 
     @complexity Linear in the length of string @a s.
     */
+//-------EXPORTED_FUNC_DEF_START json::serializer
     void dump_escaped(const string_t& s, const bool ensure_ascii)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         uint32_t codepoint;
         uint8_t state = UTF8_ACCEPT;
@@ -419,6 +426,7 @@ class serializer
             JSON_THROW(type_error::create(316, "incomplete UTF-8 string; last byte: 0x" + sn));
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief dump an integer
@@ -474,7 +482,10 @@ class serializer
 
     @param[in] x  floating-point number to dump
     */
+//-------EXPORTED_FUNC_DEF_START json::serializer
     void dump_float(number_float_t x)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // NaN / inf
         if (not std::isfinite(x))
@@ -551,6 +562,7 @@ class serializer
             o->write_characters(".0", 2);
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief check whether a string is UTF-8 encoded
@@ -573,7 +585,10 @@ class serializer
     @copyright Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
     @sa http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
     */
+//-------EXPORTED_FUNC_DEF_START json::serializer
     static uint8_t decode(uint8_t& state, uint32_t& codep, const uint8_t byte) noexcept
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         static const std::array<uint8_t, 400> utf8d =
         {
@@ -604,6 +619,7 @@ class serializer
         state = utf8d[256u + state * 16u + type];
         return state;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
   private:
     /// the output of the serializer
diff --git a/include/nlohmann/json.hpp b/include/nlohmann/json.hpp
index 52c301cf..2f240704 100644
--- a/include/nlohmann/json.hpp
+++ b/include/nlohmann/json.hpp
@@ -315,7 +315,10 @@ class basic_json
 
     @since 2.1.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     static basic_json meta()
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         basic_json result;
 
@@ -369,6 +372,7 @@ class basic_json
 #endif
         return result;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
 
     ///////////////////////////
@@ -890,7 +894,10 @@ class basic_json
         /// constructor for numbers (floating-point)
         json_value(number_float_t v) noexcept : number_float(v) {}
         /// constructor for empty values of a given type
+//-------EXPORTED_FUNC_DEF_START json
         json_value(value_t t)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
         {
             switch (t)
             {
@@ -953,6 +960,7 @@ class basic_json
                 }
             }
         }
+//-------EXPORTED_FUNC_CONTENTS_END
 
         /// constructor for strings
         json_value(const string_t& value)
@@ -990,7 +998,10 @@ class basic_json
             array = create<array_t>(std::move(value));
         }
 
+//-------EXPORTED_FUNC_DEF_START json::json_value
         void destroy(value_t t) noexcept
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
         {
             switch (t)
             {
@@ -1024,6 +1035,7 @@ class basic_json
                 }
             }
         }
+//-------EXPORTED_FUNC_CONTENTS_END
     };
 
     /*!
@@ -1398,9 +1410,12 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     basic_json(initializer_list_t init,
                bool type_deduction = true,
                value_t manual_type = value_t::array)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // check if each element is an array with two elements whose first
         // element is a string
@@ -1449,6 +1464,7 @@ class basic_json
 
         assert_invariant();
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief explicitly create an array from an initializer list
@@ -1557,12 +1573,16 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     basic_json(size_type cnt, const basic_json& val)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
         : m_type(value_t::array)
     {
         m_value.array = create<array_t>(cnt, val);
         assert_invariant();
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief construct a JSON container given an iterator range
@@ -1746,7 +1766,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     basic_json(const basic_json& other)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
         : m_type(other.m_type)
     {
         // check of passed value is valid
@@ -1802,6 +1825,7 @@ class basic_json
 
         assert_invariant();
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief move constructor
@@ -1829,7 +1853,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     basic_json(basic_json&& other) noexcept
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
         : m_type(std::move(other.m_type)),
           m_value(std::move(other.m_value))
     {
@@ -1842,6 +1869,7 @@ class basic_json
 
         assert_invariant();
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief copy assignment
@@ -1866,12 +1894,15 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     reference& operator=(basic_json other) noexcept (
         std::is_nothrow_move_constructible<value_t>::value and
         std::is_nothrow_move_assignable<value_t>::value and
         std::is_nothrow_move_constructible<json_value>::value and
         std::is_nothrow_move_assignable<json_value>::value
     )
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // check that passed value is valid
         other.assert_invariant();
@@ -1883,6 +1914,7 @@ class basic_json
         assert_invariant();
         return *this;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief destructor
@@ -1952,8 +1984,11 @@ class basic_json
     @since version 1.0.0; indentation character @a indent_char, option
            @a ensure_ascii and exceptions added in version 3.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     string_t dump(const int indent = -1, const char indent_char = ' ',
                   const bool ensure_ascii = false) const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         string_t result;
         serializer s(detail::output_adapter<char, string_t>(result), indent_char);
@@ -1969,6 +2004,7 @@ class basic_json
 
         return result;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief return the type of the JSON value (explicit)
@@ -2350,7 +2386,10 @@ class basic_json
     //////////////////
 
     /// get a boolean (explicit)
+//-------EXPORTED_FUNC_DEF_START json
     boolean_t get_impl(boolean_t* /*unused*/) const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (JSON_LIKELY(is_boolean()))
         {
@@ -2359,6 +2398,7 @@ class basic_json
 
         JSON_THROW(type_error::create(302, "type must be boolean, but is " + std::string(type_name())));
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /// get a pointer to the value (object)
     object_t* get_impl_ptr(object_t* /*unused*/) noexcept
@@ -2896,7 +2936,10 @@ class basic_json
     written using `at()`. It also demonstrates the different exceptions that
     can be thrown.,at__size_type}
     */
+//-------EXPORTED_FUNC_DEF_START json
     reference at(size_type idx)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // at only works for arrays
         if (JSON_LIKELY(is_array()))
@@ -2916,6 +2959,7 @@ class basic_json
             JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief access specified array element with bounds checking
@@ -2943,7 +2987,10 @@ class basic_json
     `at()`. It also demonstrates the different exceptions that can be thrown.,
     at__size_type_const}
     */
+//-------EXPORTED_FUNC_DEF_START json
     const_reference at(size_type idx) const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // at only works for arrays
         if (JSON_LIKELY(is_array()))
@@ -2963,6 +3010,7 @@ class basic_json
             JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief access specified object element with bounds checking
@@ -2994,7 +3042,10 @@ class basic_json
     written using `at()`. It also demonstrates the different exceptions that
     can be thrown.,at__object_t_key_type}
     */
+//-------EXPORTED_FUNC_DEF_START json
     reference at(const typename object_t::key_type& key)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // at only works for objects
         if (JSON_LIKELY(is_object()))
@@ -3014,6 +3065,7 @@ class basic_json
             JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief access specified object element with bounds checking
@@ -3045,7 +3097,10 @@ class basic_json
     `at()`. It also demonstrates the different exceptions that can be thrown.,
     at__object_t_key_type_const}
     */
+//-------EXPORTED_FUNC_DEF_START json
     const_reference at(const typename object_t::key_type& key) const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // at only works for objects
         if (JSON_LIKELY(is_object()))
@@ -3065,6 +3120,7 @@ class basic_json
             JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief access specified array element
@@ -3091,7 +3147,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     reference operator[](size_type idx)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // implicitly convert null value to an empty array
         if (is_null())
@@ -3117,6 +3176,7 @@ class basic_json
 
         JSON_THROW(type_error::create(305, "cannot use operator[] with a numeric argument with " + std::string(type_name())));
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief access specified array element
@@ -3137,7 +3197,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     const_reference operator[](size_type idx) const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // const operator[] only works for arrays
         if (JSON_LIKELY(is_array()))
@@ -3147,6 +3210,7 @@ class basic_json
 
         JSON_THROW(type_error::create(305, "cannot use operator[] with a numeric argument with " + std::string(type_name())));
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief access specified object element
@@ -3175,7 +3239,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     reference operator[](const typename object_t::key_type& key)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // implicitly convert null value to an empty object
         if (is_null())
@@ -3193,6 +3260,7 @@ class basic_json
 
         JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief read-only access specified object element
@@ -3224,7 +3292,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     const_reference operator[](const typename object_t::key_type& key) const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // const operator[] only works for objects
         if (JSON_LIKELY(is_object()))
@@ -3235,6 +3306,7 @@ class basic_json
 
         JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief access specified object element
@@ -3802,7 +3874,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     size_type erase(const typename object_t::key_type& key)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // this erase only works for objects
         if (JSON_LIKELY(is_object()))
@@ -3812,6 +3887,7 @@ class basic_json
 
         JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief remove element from a JSON array given an index
@@ -3837,7 +3913,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     void erase(const size_type idx)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // this erase only works for arrays
         if (JSON_LIKELY(is_array()))
@@ -3854,6 +3933,7 @@ class basic_json
             JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /// @}
 
@@ -3887,8 +3967,11 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     template<typename KeyT>
     iterator find(KeyT&& key)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         auto result = end();
 
@@ -3899,13 +3982,17 @@ class basic_json
 
         return result;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief find an element in a JSON object
     @copydoc find(KeyT&&)
     */
+//-------EXPORTED_FUNC_DEF_START json
     template<typename KeyT>
     const_iterator find(KeyT&& key) const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         auto result = cend();
 
@@ -3916,6 +4003,7 @@ class basic_json
 
         return result;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief returns the number of occurrences of a key in a JSON object
@@ -3938,12 +4026,16 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     template<typename KeyT>
     size_type count(KeyT&& key) const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // return 0 for all nonobject types
         return is_object() ? m_value.object->count(std::forward<KeyT>(key)) : 0;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /// @}
 
@@ -4417,7 +4509,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     bool empty() const noexcept
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         switch (m_type)
         {
@@ -4446,6 +4541,7 @@ class basic_json
             }
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief returns the number of elements
@@ -4489,7 +4585,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     size_type size() const noexcept
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         switch (m_type)
         {
@@ -4518,6 +4617,7 @@ class basic_json
             }
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief returns the maximum possible number of elements
@@ -4559,7 +4659,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     size_type max_size() const noexcept
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         switch (m_type)
         {
@@ -4582,6 +4685,7 @@ class basic_json
             }
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /// @}
 
@@ -4629,7 +4733,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     void clear() noexcept
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         switch (m_type)
         {
@@ -4679,6 +4786,7 @@ class basic_json
                 break;
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief add an object to an array
@@ -4700,7 +4808,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     void push_back(basic_json&& val)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // push_back only works for null objects or arrays
         if (JSON_UNLIKELY(not(is_null() or is_array())))
@@ -4721,6 +4832,7 @@ class basic_json
         // invalidate object
         val.m_type = value_t::null;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief add an object to an array
@@ -4736,7 +4848,10 @@ class basic_json
     @brief add an object to an array
     @copydoc push_back(basic_json&&)
     */
+//-------EXPORTED_FUNC_DEF_START json
     void push_back(const basic_json& val)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // push_back only works for null objects or arrays
         if (JSON_UNLIKELY(not(is_null() or is_array())))
@@ -4755,6 +4870,7 @@ class basic_json
         // add element to array
         m_value.array->push_back(val);
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief add an object to an array
@@ -4841,7 +4957,10 @@ class basic_json
     @liveexample{The example shows how initializer lists are treated as
     objects when possible.,push_back__initializer_list}
     */
+//-------EXPORTED_FUNC_DEF_START json
     void push_back(initializer_list_t init)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (is_object() and init.size() == 2 and (*init.begin())->is_string())
         {
@@ -4854,6 +4973,7 @@ class basic_json
             push_back(basic_json(init));
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief add an object to an object
@@ -5003,7 +5123,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     iterator insert(const_iterator pos, const basic_json& val)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // insert only works for arrays
         if (JSON_LIKELY(is_array()))
@@ -5020,6 +5143,7 @@ class basic_json
 
         JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief inserts element
@@ -5054,7 +5178,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     iterator insert(const_iterator pos, size_type cnt, const basic_json& val)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // insert only works for arrays
         if (JSON_LIKELY(is_array()))
@@ -5071,6 +5198,7 @@ class basic_json
 
         JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief inserts elements
@@ -5102,7 +5230,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     iterator insert(const_iterator pos, const_iterator first, const_iterator last)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // insert only works for arrays
         if (JSON_UNLIKELY(not is_array()))
@@ -5130,6 +5261,7 @@ class basic_json
         // insert to array and return iterator
         return insert_iterator(pos, first.m_it.array_iterator, last.m_it.array_iterator);
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief inserts elements
@@ -5155,7 +5287,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     iterator insert(const_iterator pos, initializer_list_t ilist)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // insert only works for arrays
         if (JSON_UNLIKELY(not is_array()))
@@ -5172,6 +5307,7 @@ class basic_json
         // insert to array and return iterator
         return insert_iterator(pos, ilist.begin(), ilist.end());
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief inserts elements
@@ -5196,7 +5332,10 @@ class basic_json
 
     @since version 3.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     void insert(const_iterator first, const_iterator last)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // insert only works for objects
         if (JSON_UNLIKELY(not is_object()))
@@ -5218,6 +5357,7 @@ class basic_json
 
         m_value.object->insert(first.m_it.object_iterator, last.m_it.object_iterator);
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief updates a JSON object from another object, overwriting existing keys
@@ -5238,7 +5378,10 @@ class basic_json
 
     @since version 3.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     void update(const_reference j)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // implicitly convert null value to an empty object
         if (is_null())
@@ -5262,6 +5405,7 @@ class basic_json
             m_value.object->operator[](it.key()) = it.value();
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief updates a JSON object from another object, overwriting existing keys
@@ -5289,7 +5433,10 @@ class basic_json
 
     @since version 3.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     void update(const_iterator first, const_iterator last)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // implicitly convert null value to an empty object
         if (is_null())
@@ -5322,6 +5469,7 @@ class basic_json
             m_value.object->operator[](it.key()) = it.value();
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief exchanges the values
@@ -5372,7 +5520,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     void swap(array_t& other)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // swap only works for arrays
         if (JSON_LIKELY(is_array()))
@@ -5384,6 +5535,7 @@ class basic_json
             JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief exchanges the values
@@ -5405,7 +5557,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     void swap(object_t& other)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // swap only works for objects
         if (JSON_LIKELY(is_object()))
@@ -5417,6 +5572,7 @@ class basic_json
             JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief exchanges the values
@@ -5438,7 +5594,10 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     void swap(string_t& other)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // swap only works for strings
         if (JSON_LIKELY(is_string()))
@@ -5450,6 +5609,7 @@ class basic_json
             JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /// @}
 
@@ -5500,8 +5660,13 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     friend bool operator==(const_reference lhs, const_reference rhs) noexcept
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
+        using value_t = json::value_t;
+
         const auto lhs_type = lhs.type();
         const auto rhs_type = rhs.type();
 
@@ -5564,6 +5729,7 @@ class basic_json
 
         return false;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief comparison: equal
@@ -5658,8 +5824,12 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     friend bool operator<(const_reference lhs, const_reference rhs) noexcept
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
+        using value_t = json::value_t;
         const auto lhs_type = lhs.type();
         const auto rhs_type = rhs.type();
 
@@ -5725,6 +5895,7 @@ class basic_json
         // because MSVC has problems otherwise.
         return operator<(lhs_type, rhs_type);
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief comparison: less than
@@ -5926,7 +6097,10 @@ class basic_json
 
     @since version 1.0.0; indentation character added in version 3.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     friend std::ostream& operator<<(std::ostream& o, const basic_json& j)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // read width member and use it as indentation parameter if nonzero
         const bool pretty_print = (o.width() > 0);
@@ -5940,6 +6114,7 @@ class basic_json
         s.dump(j, pretty_print, false, static_cast<unsigned int>(indentation));
         return o;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief serialize to stream
@@ -6027,19 +6202,27 @@ class basic_json
 
     @since version 2.0.3 (contiguous containers)
     */
+//-------EXPORTED_FUNC_DEF_START json
     static basic_json parse(detail::input_adapter&& i,
                             const parser_callback_t cb = nullptr,
                             const bool allow_exceptions = true)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         basic_json result;
         parser(i, cb, allow_exceptions).parse(true, result);
         return result;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
+//-------EXPORTED_FUNC_DEF_START json
     static bool accept(detail::input_adapter&& i)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         return parser(i).accept(true);
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief generate SAX events
@@ -6097,10 +6280,13 @@ class basic_json
 
     @since version 3.2.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     template <typename SAX>
     static bool sax_parse(detail::input_adapter&& i, SAX* sax,
                           input_format_t format = input_format_t::json,
                           const bool strict = true)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         assert(sax);
         switch (format)
@@ -6111,6 +6297,7 @@ class basic_json
                 return detail::binary_reader<basic_json, SAX>(std::move(i)).sax_parse(format, sax, strict);
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief deserialize from an iterator range with contiguous storage
@@ -6229,11 +6416,14 @@ class basic_json
 
     @since version 1.0.0
     */
+//-------EXPORTED_FUNC_DEF_START
     friend std::istream& operator>>(std::istream& i, basic_json& j)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
-        parser(detail::input_adapter(i)).parse(false, j);
         return i;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /// @}
 
@@ -6271,7 +6461,10 @@ class basic_json
     @since version 1.0.0, public since 2.1.0, `const char*` and `noexcept`
     since 3.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     const char* type_name() const noexcept
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         {
             switch (m_type)
@@ -6293,6 +6486,7 @@ class basic_json
             }
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
 
   private:
@@ -6402,22 +6596,32 @@ class basic_json
 
     @since version 2.0.9
     */
+//-------EXPORTED_FUNC_DEF_START json
     static std::vector<uint8_t> to_cbor(const basic_json& j)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         std::vector<uint8_t> result;
         to_cbor(j, result);
         return result;
     }
-
+//-------EXPORTED_FUNC_CONTENTS_END
+//-------EXPORTED_FUNC_DEF_START json
     static void to_cbor(const basic_json& j, detail::output_adapter<uint8_t> o)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         binary_writer<uint8_t>(o).write_cbor(j);
     }
-
+//-------EXPORTED_FUNC_CONTENTS_END
+//-------EXPORTED_FUNC_DEF_START json
     static void to_cbor(const basic_json& j, detail::output_adapter<char> o)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         binary_writer<char>(o).write_cbor(j);
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief create a MessagePack serialization of a given JSON value
@@ -6499,22 +6703,32 @@ class basic_json
 
     @since version 2.0.9
     */
+//-------EXPORTED_FUNC_DEF_START json
     static std::vector<uint8_t> to_msgpack(const basic_json& j)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         std::vector<uint8_t> result;
         to_msgpack(j, result);
         return result;
     }
-
+//-------EXPORTED_FUNC_CONTENTS_END
+//-------EXPORTED_FUNC_DEF_START json
     static void to_msgpack(const basic_json& j, detail::output_adapter<uint8_t> o)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         binary_writer<uint8_t>(o).write_msgpack(j);
     }
-
+//-------EXPORTED_FUNC_CONTENTS_END
+//-------EXPORTED_FUNC_DEF_START json
     static void to_msgpack(const basic_json& j, detail::output_adapter<char> o)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         binary_writer<char>(o).write_msgpack(j);
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief create a UBJSON serialization of a given JSON value
@@ -6596,26 +6810,36 @@ class basic_json
 
     @since version 3.1.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     static std::vector<uint8_t> to_ubjson(const basic_json& j,
                                           const bool use_size = false,
                                           const bool use_type = false)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         std::vector<uint8_t> result;
         to_ubjson(j, result, use_size, use_type);
         return result;
     }
-
+//-------EXPORTED_FUNC_CONTENTS_END
+//-------EXPORTED_FUNC_DEF_START json
     static void to_ubjson(const basic_json& j, detail::output_adapter<uint8_t> o,
                           const bool use_size = false, const bool use_type = false)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         binary_writer<uint8_t>(o).write_ubjson(j, use_size, use_type);
     }
-
+//-------EXPORTED_FUNC_CONTENTS_END
+//-------EXPORTED_FUNC_DEF_START json
     static void to_ubjson(const basic_json& j, detail::output_adapter<char> o,
                           const bool use_size = false, const bool use_type = false)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         binary_writer<char>(o).write_ubjson(j, use_size, use_type);
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief create a JSON value from an input in CBOR format
@@ -6714,15 +6938,19 @@ class basic_json
            @a strict parameter since 3.0.0; added @allow_exceptions parameter
            since 3.2.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     static basic_json from_cbor(detail::input_adapter&& i,
                                 const bool strict = true,
                                 const bool allow_exceptions = true)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         basic_json result;
         detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
         const bool res = binary_reader(detail::input_adapter(i)).sax_parse(input_format_t::cbor, &sdp, strict);
         return res ? result : basic_json(value_t::discarded);
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @copydoc from_cbor(detail::input_adapter, const bool, const bool)
@@ -6817,15 +7045,19 @@ class basic_json
            @a strict parameter since 3.0.0; added @allow_exceptions parameter
            since 3.2.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     static basic_json from_msgpack(detail::input_adapter&& i,
                                    const bool strict = true,
                                    const bool allow_exceptions = true)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         basic_json result;
         detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
         const bool res = binary_reader(detail::input_adapter(i)).sax_parse(input_format_t::msgpack, &sdp, strict);
         return res ? result : basic_json(value_t::discarded);
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @copydoc from_msgpack(detail::input_adapter, const bool, const bool)
@@ -6899,15 +7131,19 @@ class basic_json
 
     @since version 3.1.0; added @allow_exceptions parameter since 3.2.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     static basic_json from_ubjson(detail::input_adapter&& i,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         basic_json result;
         detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
         const bool res = binary_reader(detail::input_adapter(i)).sax_parse(input_format_t::ubjson, &sdp, strict);
         return res ? result : basic_json(value_t::discarded);
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @copydoc from_ubjson(detail::input_adapter, const bool, const bool)
@@ -7205,7 +7441,10 @@ class basic_json
 
     @since version 2.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     basic_json patch(const basic_json& json_patch) const
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // make a working copy to apply the patch to
         basic_json result = *this;
@@ -7471,6 +7710,7 @@ class basic_json
 
         return result;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /*!
     @brief creates a diff as a JSON patch
@@ -7505,8 +7745,11 @@ class basic_json
 
     @since version 2.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     static basic_json diff(const basic_json& source, const basic_json& target,
                            const std::string& path = "")
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         // the patch
         basic_json result(value_t::array);
@@ -7629,6 +7872,7 @@ class basic_json
 
         return result;
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /// @}
 
@@ -7681,7 +7925,10 @@ class basic_json
 
     @since version 3.0.0
     */
+//-------EXPORTED_FUNC_DEF_START json
     void merge_patch(const basic_json& patch)
+//-------EXPORTED_FUNC_DEF_END
+//-------EXPORTED_FUNC_CONTENTS_START
     {
         if (patch.is_object())
         {
@@ -7706,6 +7953,7 @@ class basic_json
             *this = patch;
         }
     }
+//-------EXPORTED_FUNC_CONTENTS_END
 
     /// @}
 };
